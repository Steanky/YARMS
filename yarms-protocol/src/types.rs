//!
//! Contains basic "primitives" of the Minecraft protocol, with [`ProtocolRead`] and
//! [`ProtocolWrite`] implementations for them, and some useful constants.
//!
//! These so-called primitives generally meet several criteria:
//! * They are "simple": basic types that form the basis of other types, but are themselves fairly
//!   simple in terms of how they are represented: they are composed of few, if any, more
//!   fundamental types themselves
//! * They are "stable": as the Minecraft protocol updates, the way these types work is unlikely to
//!   change in a way that would render them backwards-incompatible with older versions
//! * They are "version-agnostic": nothing about them is tied to a specific version of the game
//!
//! A good example of a stable primitive is [`VarInt`]: it has remained the same for a long time,
//! and it appears unlikely to change in the future.
//!
//! A bad example of a primitive, that should NOT be included in this library, is a "boss bar
//! action" for use with the
//! [boss bar packet](https://minecraft.wiki/w/Java_Edition_protocol#Boss_Bar). Such a type is
//! composed primarily of other types, is liable to change in the future, and not version-agnostic.
//!
//! Types like boss bar actions should instead be included in the code generated by `yarms-datagen`.

use crate::{util, validation_error, ProtocolRead, ProtocolWrite, Result};
use bytes::{Buf, BufMut};

use crate::util::LebFlow;
use alloc::borrow::Cow;
use alloc::borrow::ToOwned;
use alloc::boxed::Box;
use alloc::string::String;
use alloc::vec;
use alloc::vec::Vec;
use core::borrow::Borrow;
use core::fmt::Debug;
use core::ops::Deref;
use core::ops::DerefMut;

///
/// Maximum number of bytes needed to encode a single [`VarInt`], always equal to `5`.
pub const MAX_VAR_INT_BYTES: usize = 5;

///
/// Maximum number of bytes needed to encode a single [`VarLong`], always equal to `10`.
pub const MAX_VAR_LONG_BYTES: usize = 10;

///
/// Maximum size of a [`VarString`], in bytes, not counting the length prefix.
pub const MAX_STRING_LENGTH: i32 = 98301;

///
/// Boolean `true`.
pub const TRUE: Boolean = Boolean(true);

///
/// Boolean `false`.
pub const FALSE: Boolean = Boolean(false);

///
/// Macro to generate boilerplate for "transparent wrapper" [`ProtocolType`]s such as [`Boolean`].
macro_rules! wrapper_impl {
    ( $target:ty, $inner:ty ) => {
        impl core::ops::Deref for $target {
            type Target = $inner;

            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }

        impl core::ops::DerefMut for $target {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }

        impl core::default::Default for $target {
            fn default() -> Self {
                <Self as core::convert::From<$inner>>::from(
                    <$inner as core::default::Default>::default(),
                )
            }
        }

        impl core::convert::From<$inner> for $target {
            fn from(inner: $inner) -> Self {
                Self(inner)
            }
        }

        impl core::convert::From<$target> for $inner {
            fn from(target: $target) -> Self {
                target.0
            }
        }

        impl core::borrow::Borrow<$inner> for $target {
            fn borrow(&self) -> &$inner {
                &self.0
            }
        }
    };
}

///
/// Macro to generate boilerplate for types that dereference into "base" [`ProtocolType`]s.
macro_rules! deref_protocol_read_impl {
    ( $base_ty:ty, $deref_ty:ty ) => {
        type Output = $base_ty;

        fn read_from<B: bytes::Buf + ?Sized>(
            read: &mut B,
            end_remaining: usize,
        ) -> crate::Result<Self::Output> {
            <$deref_ty>::read_from(read, end_remaining)
        }
    };
}

///
/// Macro to generate boilerplate for types that dereference into "base" [`ProtocolType`]s.
macro_rules! deref_protocol_write_impl {
    ( $base_ty:ty, $deref_ty:ty ) => {
        fn write_to<B: BufMut + ?Sized>(&self, write: &mut B) -> usize {
            <$deref_ty as ProtocolWrite>::write_to(self.deref(), write)
        }

        fn len(&self) -> usize {
            <$deref_ty as ProtocolWrite>::len(self.deref())
        }
    };
}

///
/// Boolean type, wrapping (and dereferencing to) a Rust `bool`. Can be either `true` or `false`.
/// Always takes up a single byte when serialized.
///
/// This type is guaranteed to have the same in-memory representation as a [`bool`].
#[derive(Copy, Clone, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[repr(transparent)]
pub struct Boolean(bool);

///
/// Byte type, dereferencing to a Rust `i8`. Can be any value from [`i8::MIN`] to [`i8::MAX`],
/// inclusive. Always takes up 1 byte when serialized.
///
/// This type is guaranteed to have the same in-memory representation as an [`i8`].
#[derive(Copy, Clone, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[repr(transparent)]
pub struct Byte(i8);

///
/// `UnsignedByte` type, dereferencing to a Rust `i8`. Can be any value from [`u8::MIN`] to
/// [`u8::MAX`],  inclusive. Always takes up 1 byte when serialized.
///
/// This type is guaranteed to have the same in-memory representation as a [`u8`].
#[derive(Copy, Clone, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[repr(transparent)]
pub struct UnsignedByte(u8);

///
/// `Short` type, dereferencing to a Rust `i16`. Can be any value from [`i16::MIN`] to [`i16::MAX`],
/// inclusive. Always takes up 2 bytes when serialized.
///
/// This type is guaranteed to have the same in-memory representation as a [`i16`].
#[derive(Copy, Clone, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[repr(transparent)]
pub struct Short(i16);

///
/// `UnsignedShort` type, dereferencing to a Rust `u16`. Can be any value from [`u16::MIN`] to
/// [`u16::MAX`],  inclusive. Always takes up 2 bytes when serialized.
///
/// This type is guaranteed to have the same in-memory representation as a [`u16`].
#[derive(Copy, Clone, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[repr(transparent)]
pub struct UnsignedShort(u16);

///
/// Int type, dereferencing to a Rust `i32`. Can be any value from [`i32::MIN`] to [`i32::MAX`],
/// inclusive. Always takes up 4 bytes when serialized. For the variable-length type, see
/// [`VarInt`].
///
/// This type is guaranteed to have the same in-memory representation as an [`i32`].
#[derive(Copy, Clone, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[repr(transparent)]
pub struct Int(i32);

///
/// Long type, dereferencing to a Rust `i64`. Can be any value from [`i64::MIN`] to [`i64::MAX`],
/// inclusive. Always takes up 8 bytes when serialized. For the variable-length type, see
/// [`VarLong`].
///
/// This type is guaranteed to have the same in-memory representation as an [`i64`].
#[derive(Copy, Clone, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[repr(transparent)]
pub struct Long(i64);

///
/// Float type, dereferencing to a Rust [`f32`]. Can be any valid [`f32`] value. Takes 4 bytes when
/// serializing.
///
/// This type is guaranteed to have the same in-memory representation as an [`f32`].
#[derive(Copy, Clone, Debug, PartialEq, PartialOrd)]
#[repr(transparent)]
pub struct Float(f32);

///
/// Double type, dereferencing to a Rust [`f64`]. Can be any valid [`f64`] value. Takes 8 bytes
/// when serializing.
///
/// This type is guaranteed to have the same in-memory representation as an [`f64`].
#[derive(Copy, Clone, Debug, PartialEq, PartialOrd)]
#[repr(transparent)]
pub struct Double(f64);

///
/// Variable-length [`i32`] using LEB-128 encoding. Can take up anywhere from 1 to
/// [`MAX_VAR_INT_BYTES`], inclusive. For a fixed-length `i32`, see [`Int`].
///
/// To compute the byte length of a `VarInt`, call [`util::var_int_len`] or [`VarInt::len`],
/// whichever is more convenient.
///
/// This type is guaranteed to have the same in-memory representation as an [`i32`].
#[derive(Copy, Clone, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[repr(transparent)]
pub struct VarInt(i32);

///
/// Variable-length [`i64`] using LEB-128 encoding. Can take up anywhere from 1 to
/// [`MAX_VAR_LONG_BYTES`], inclusive. For a fixed-length `i64`, see [`Long`].
///
/// To compute the byte length of a `VarLong`, call [`util::var_long_len`] or [`VarLong::len`],
/// whichever is more convenient.
///
/// This type is guaranteed to have the same in-memory representation as an [`i64`].
#[derive(Copy, Clone, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[repr(transparent)]
pub struct VarLong(i64);

///
/// Uuid type, dereferencing to a Rust `u128`. Can be any value from [`u128::MIN`] to [`u128::MAX`],
/// inclusive. Always takes up 16 bytes when serialized.
///
/// This type is guaranteed to have the same in-memory representation as a [`u128`].
#[derive(Copy, Clone, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[repr(transparent)]
pub struct Uuid(u128);

///
/// A byte array whose length (when read) is always just the number of bytes remaining in the
/// packet. Has the same in-memory representation as `Cow<'a, [u8]>`.
///
/// This type should always be the last one that's read for any particular packet, as it "consumes"
/// the rest of the bytes.
///
/// Dereferences to `&[u8]`.
#[derive(Clone, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[repr(transparent)]
pub struct RemainingByteArray<'a>(Cow<'a, [u8]>);

#[doc(hidden)]
///
/// A placeholder [`ProtocolType`] that will panic if used (read or written). It's currently only
/// used as an ad-hoc "default type" for code generation facilities, that allows the project to
/// build even if the correct type cannot be determined.
///
/// Not intended for use in user code.
#[derive(Clone, Debug, PartialEq, Eq, Ord, PartialOrd, Hash)]
pub struct Unimplemented();

wrapper_impl!(Boolean, bool);
wrapper_impl!(Byte, i8);
wrapper_impl!(UnsignedByte, u8);
wrapper_impl!(Short, i16);
wrapper_impl!(UnsignedShort, u16);
wrapper_impl!(Int, i32);
wrapper_impl!(Long, i64);
wrapper_impl!(Float, f32);
wrapper_impl!(Double, f64);
wrapper_impl!(VarInt, i32);
wrapper_impl!(VarLong, i64);
wrapper_impl!(Uuid, u128);

impl RemainingByteArray<'_> {
    ///
    /// Creates a [`RemainingByteArray`] from an arbitrary slice of bytes.
    pub fn from_slice(bytes: &[u8]) -> RemainingByteArray {
        RemainingByteArray(Cow::Borrowed(bytes))
    }

    ///
    /// Creates a [`RemainingByteArray`] from an owned vector of bytes.
    pub fn from_owned(bytes: Vec<u8>) -> RemainingByteArray<'static> {
        RemainingByteArray(Cow::Owned(bytes))
    }

    ///
    /// Converts this type into a `Vec<u8>`. This conversion is free unless the `RemainingByteArray`
    /// was created using [`Self::from_slice`].
    pub fn into_owned(self) -> Vec<u8> {
        self.0.into_owned()
    }
}

impl Deref for RemainingByteArray<'_> {
    type Target = [u8];

    fn deref(&self) -> &Self::Target {
        self.0.deref()
    }
}

impl ProtocolRead for Unimplemented {
    type Output = Self;

    fn read_from<B: Buf + ?Sized>(_: &mut B, _: usize) -> Result<Self::Output> {
        unimplemented!()
    }
}

impl ProtocolWrite for Unimplemented {
    fn write_to<B: BufMut + ?Sized>(&self, _: &mut B) -> usize {
        unimplemented!()
    }

    fn len(&self) -> usize {
        unimplemented!()
    }
}

#[cold]
#[inline(never)]
fn length_err() -> Result<()> {
    validation_error!(Read "length was out of range")
}

///
/// Checks that some value `len` is between `min` and `max`.
#[inline]
pub fn validate_len<T>(len: T, min: T, max: T) -> Result<()>
where
    T: PartialOrd + Copy,
{
    if len >= min && len <= max {
        Ok(())
    } else {
        length_err()
    }
}

fn read_string_from<B>(read: &mut B, max_len: i32) -> Result<String>
where
    B: Buf + ?Sized,
{
    let length = read_length_prefix(read, max_len)?;

    let mut bytes = vec![0; length];
    read.copy_to_slice(&mut bytes);

    String::from_utf8(bytes).map_err(|_| validation_error!(*Read "string was invalid UTF-8"))
}

fn write_string_to<B>(write: &mut B, string: &str) -> usize
where
    B: BufMut + ?Sized,
{
    let bytes = string.as_bytes();
    let length_bytes = VarInt::from(bytes.len() as i32).write_to(write);

    write.put_slice(bytes);
    length_bytes + bytes.len()
}

fn read_length_prefix<B>(read: &mut B, max: i32) -> Result<usize>
where
    B: Buf + ?Sized,
{
    let array_len = *VarInt::read_from(read, 0)?;
    validate_len(array_len, 0, max)?;

    if array_len as usize > read.remaining() {
        return validation_error!(Read "length exceeds buffer capacity");
    }

    Ok(array_len as usize)
}

impl ProtocolRead for Boolean {
    type Output = Self;

    fn read_from<B: Buf + ?Sized>(read: &mut B, _: usize) -> Result<Self::Output> {
        match read.try_get_u8()? {
            0 => Ok(FALSE),
            1 => Ok(TRUE),
            _ => validation_error!(Read "invalid boolean"),
        }
    }
}

impl ProtocolWrite for Boolean {
    fn write_to<B: BufMut + ?Sized>(&self, write: &mut B) -> usize {
        write.put_u8(u8::from(**self));
        self.len()
    }

    fn len(&self) -> usize {
        1
    }
}

impl ProtocolRead for Byte {
    type Output = Self;

    fn read_from<B: Buf + ?Sized>(read: &mut B, _: usize) -> Result<Self::Output> {
        Ok(Byte::from(read.try_get_i8()?))
    }
}

impl ProtocolWrite for Byte {
    fn write_to<B: BufMut + ?Sized>(&self, write: &mut B) -> usize {
        write.put_i8(**self);
        self.len()
    }

    fn len(&self) -> usize {
        1
    }
}

impl ProtocolRead for UnsignedByte {
    type Output = Self;

    fn read_from<B: Buf + ?Sized>(read: &mut B, _: usize) -> Result<Self::Output> {
        Ok(UnsignedByte::from(read.try_get_u8()?))
    }
}

impl ProtocolWrite for UnsignedByte {
    fn write_to<B: BufMut + ?Sized>(&self, write: &mut B) -> usize {
        write.put_u8(**self);
        self.len()
    }

    fn len(&self) -> usize {
        1
    }
}

impl ProtocolRead for Short {
    type Output = Self;

    fn read_from<B: Buf + ?Sized>(read: &mut B, _: usize) -> Result<Self::Output> {
        Ok(Short::from(read.try_get_i16()?))
    }
}

impl ProtocolWrite for Short {
    fn write_to<B: BufMut + ?Sized>(&self, write: &mut B) -> usize {
        write.put_i16(**self);
        self.len()
    }

    fn len(&self) -> usize {
        2
    }
}

impl ProtocolRead for UnsignedShort {
    type Output = Self;

    fn read_from<B: Buf + ?Sized>(read: &mut B, _: usize) -> Result<Self::Output> {
        Ok(UnsignedShort::from(read.try_get_u16()?))
    }
}

impl ProtocolWrite for UnsignedShort {
    fn write_to<B: BufMut + ?Sized>(&self, write: &mut B) -> usize {
        write.put_u16(**self);
        self.len()
    }

    fn len(&self) -> usize {
        2
    }
}

impl ProtocolRead for Int {
    type Output = Self;

    fn read_from<B: Buf + ?Sized>(read: &mut B, _: usize) -> Result<Self::Output>
    where
        Self: Sized,
    {
        Ok(Int::from(read.try_get_i32()?))
    }
}

impl ProtocolWrite for Int {
    fn write_to<B: BufMut + ?Sized>(&self, write: &mut B) -> usize {
        write.put_i32(**self);
        self.len()
    }

    fn len(&self) -> usize {
        4
    }
}

impl ProtocolRead for Long {
    type Output = Self;

    fn read_from<B: Buf + ?Sized>(read: &mut B, _: usize) -> Result<Self::Output> {
        Ok(Long::from(read.try_get_i64()?))
    }
}

impl ProtocolWrite for Long {
    fn write_to<B: BufMut + ?Sized>(&self, write: &mut B) -> usize {
        write.put_i64(**self);
        self.len()
    }

    fn len(&self) -> usize {
        8
    }
}

impl ProtocolRead for Float {
    type Output = Self;

    fn read_from<B: Buf + ?Sized>(read: &mut B, _: usize) -> Result<Self::Output> {
        Ok(Float::from(read.try_get_f32()?))
    }
}

impl ProtocolWrite for Float {
    fn write_to<B: BufMut + ?Sized>(&self, write: &mut B) -> usize {
        write.put_f32(**self);
        self.len()
    }

    fn len(&self) -> usize {
        4
    }
}

impl ProtocolRead for Double {
    type Output = Self;

    fn read_from<B: Buf + ?Sized>(read: &mut B, _: usize) -> Result<Self::Output> {
        Ok(Double::from(read.try_get_f64()?))
    }
}

impl ProtocolWrite for Double {
    fn write_to<B: BufMut + ?Sized>(&self, write: &mut B) -> usize {
        write.put_f64(**self);
        self.len()
    }

    fn len(&self) -> usize {
        8
    }
}

impl ProtocolRead for Uuid {
    type Output = Self;

    fn read_from<B: Buf + ?Sized>(read: &mut B, _: usize) -> Result<Self::Output> {
        Ok(Uuid::from(read.try_get_u128()?))
    }
}

impl ProtocolWrite for Uuid {
    fn write_to<B: BufMut + ?Sized>(&self, write: &mut B) -> usize {
        write.put_u128(**self);
        self.len()
    }

    fn len(&self) -> usize {
        16
    }
}

impl ProtocolRead for RemainingByteArray<'static> {
    type Output = Self;

    fn read_from<B: Buf + ?Sized>(read: &mut B, end_remaining: usize) -> Result<Self::Output> {
        let target = read
            .remaining()
            .checked_sub(end_remaining)
            .ok_or_else(|| validation_error!(*Read "packet was unexpectedly small"))?;

        let mut container = vec![0; target];
        read.try_copy_to_slice(&mut container[..])?;

        Ok(RemainingByteArray(Cow::Owned(container)))
    }
}

impl ProtocolWrite for RemainingByteArray<'_> {
    fn write_to<B: BufMut + ?Sized>(&self, write: &mut B) -> usize {
        write.put_slice(&self.0[..]);
        self.len()
    }

    fn len(&self) -> usize {
        self.0.len()
    }
}

impl ProtocolRead for VarInt {
    type Output = Self;

    #[inline]
    fn read_from<B: Buf + ?Sized>(read: &mut B, _: usize) -> Result<Self::Output> {
        util::var_int_read_buf(read).map(|(_, var_int)| var_int)
    }
}

impl ProtocolWrite for VarInt {
    #[inline]
    fn write_to<B: BufMut + ?Sized>(&self, write: &mut B) -> usize {
        util::var_int_write_buf(**self, write)
    }

    #[inline]
    fn len(&self) -> usize {
        util::var_int_len(**self)
    }
}

impl ProtocolRead for VarLong {
    type Output = Self;

    fn read_from<B: Buf + ?Sized>(read: &mut B, _: usize) -> Result<Self::Output>
    where
        Self: Sized,
    {
        let mut pos = 0;
        let mut value = 0;
        loop {
            let next_byte = read.try_get_u8()?;
            if util::var_long_advance_read(next_byte, &mut pos, &mut value)? == LebFlow::Done {
                return Ok(VarLong::from(value));
            }
        }
    }
}

impl ProtocolWrite for VarLong {
    fn write_to<B: BufMut + ?Sized>(&self, write: &mut B) -> usize {
        let mut bytes_written = 0;
        let mut value = **self;
        loop {
            let mut out = 0;
            let result = util::var_long_advance_write(&mut out, &mut value);
            write.put_u8(out);
            bytes_written += 1;

            if result == LebFlow::Done {
                return bytes_written;
            }
        }
    }

    fn len(&self) -> usize {
        util::var_long_len(**self)
    }
}

impl ProtocolRead for str {
    type Output = String;

    fn read_from<B: Buf + ?Sized>(read: &mut B, _: usize) -> Result<Self::Output> {
        read_string_from(read, MAX_STRING_LENGTH)
    }
}

impl ProtocolWrite for str {
    fn write_to<B: BufMut + ?Sized>(&self, write: &mut B) -> usize {
        write_string_to(write, self)
    }

    fn len(&self) -> usize {
        util::prefixed_len(str::len(self))
    }
}

impl ProtocolRead for String {
    deref_protocol_read_impl!(String, str);
}

impl ProtocolWrite for String {
    deref_protocol_write_impl!(String, str);
}

impl ProtocolRead for [u8] {
    type Output = Vec<u8>;

    fn read_from<B: Buf + ?Sized>(read: &mut B, _: usize) -> Result<Self::Output> {
        let array_len = read_length_prefix(read, i32::MAX)?;

        let mut array = vec![0_u8; array_len];
        read.copy_to_slice(&mut array);

        Ok(array)
    }
}

impl ProtocolWrite for [u8] {
    fn write_to<B: BufMut + ?Sized>(&self, write: &mut B) -> usize {
        let length_bytes = VarInt::from(self.len() as i32).write_to(write);

        write.put_slice(&self);
        length_bytes + self.len()
    }

    fn len(&self) -> usize {
        util::prefixed_len(<[u8]>::len(self))
    }
}

impl ProtocolRead for Vec<u8> {
    deref_protocol_read_impl!(Vec<u8>, [u8]);
}

impl ProtocolWrite for Vec<u8> {
    deref_protocol_write_impl!(Vec<u8>, [u8]);
}

impl<In> ProtocolRead for [In]
where
    In: ProtocolRead,
{
    type Output = Vec<In::Output>;

    fn read_from<B: Buf + ?Sized>(read: &mut B, end_remaining: usize) -> Result<Self::Output> {
        let array_len = read_length_prefix(read, i32::MAX)?;
        let mut array = Vec::with_capacity(array_len);

        for _ in 0..array_len {
            array.push(In::read_from(read, end_remaining)?);
        }

        Ok(array)
    }
}

impl<In> ProtocolWrite for [In]
where
    In: ProtocolWrite,
{
    fn write_to<B: BufMut + ?Sized>(&self, write: &mut B) -> usize {
        let length_bytes = VarInt::from(self.len() as i32).write_to(write);

        for element in self {
            element.write_to(write);
        }

        length_bytes + self.len()
    }

    fn len(&self) -> usize {
        util::prefixed_len(self.iter().map(In::len).sum::<usize>())
    }
}

impl<In> ProtocolRead for Vec<In>
where
    In: ProtocolRead,
{
    deref_protocol_read_impl!(Vec<In::Output>, [In]);
}

impl<In> ProtocolWrite for Vec<In>
where
    In: ProtocolWrite,
{
    deref_protocol_write_impl!(Vec<In>, [In]);
}

impl<In> ProtocolRead for Option<In>
where
    In: ProtocolRead,
{
    type Output = Option<In::Output>;

    fn read_from<B: Buf + ?Sized>(read: &mut B, end_remaining: usize) -> Result<Self::Output> {
        if !*Boolean::read_from(read, 0)? {
            return Ok(None);
        }

        Ok(Some(In::read_from(read, end_remaining)?))
    }
}

impl<In> ProtocolWrite for Option<In>
where
    In: ProtocolWrite,
{
    fn write_to<B: BufMut + ?Sized>(&self, write: &mut B) -> usize {
        match self {
            None => FALSE.write_to(write),
            Some(inner) => TRUE.write_to(write) + inner.write_to(write),
        }
    }

    fn len(&self) -> usize {
        match self {
            None => FALSE.len(),
            Some(inner) => TRUE.len() + inner.len(),
        }
    }
}

impl<In> ProtocolRead for Box<In>
where
    In: ProtocolRead + ?Sized,
{
    type Output = Box<In::Output>;

    fn read_from<B: Buf + ?Sized>(read: &mut B, end_remaining: usize) -> Result<Self::Output> {
        Ok(Box::new(In::read_from(read, end_remaining)?))
    }
}

impl<In> ProtocolWrite for Box<In>
where
    In: ProtocolWrite + ?Sized,
{
    fn write_to<B: BufMut + ?Sized>(&self, write: &mut B) -> usize {
        (**self).write_to(write)
    }

    fn len(&self) -> usize {
        (**self).len()
    }
}

impl<In> ProtocolRead for Cow<'static, In>
where
    In: ProtocolRead + ToOwned<Owned = <In as ProtocolRead>::Output> + ?Sized + 'static,
{
    type Output = Self;

    fn read_from<B: Buf + ?Sized>(read: &mut B, end_remaining: usize) -> Result<Self::Output> {
        Ok(Cow::Owned(In::read_from(read, end_remaining)?))
    }
}

impl<In> ProtocolWrite for Cow<'_, In>
where
    In: ProtocolWrite + ToOwned + ?Sized,
{
    fn write_to<B: BufMut + ?Sized>(&self, write: &mut B) -> usize {
        self.as_ref().write_to(write)
    }

    fn len(&self) -> usize {
        self.as_ref().len()
    }
}

impl<const N: usize, T> ProtocolRead for [T; N]
where
    T: ProtocolRead,
{
    type Output = [T::Output; N];

    fn read_from<B: Buf + ?Sized>(read: &mut B, end_remaining: usize) -> Result<Self::Output> {
        if N == 0 {
            let arr = core::array::from_fn::<T::Output, N, _>(|_| unreachable!());
            return Ok(arr);
        }

        let mut data: [core::mem::MaybeUninit<T::Output>; N] =
            [const { core::mem::MaybeUninit::uninit() }; N];

        ///
        /// Drops the first `init` elements of `data`. Doesn't check if `D` actually needs to be
        /// dropped or not.
        ///
        /// # Safety
        /// At least `init` elements must have been initialized. They must all be properly aligned,
        /// non-null, and valid for dropping.
        unsafe fn drop_initialized<D, const N: usize>(
            init: usize,
            mut data: [core::mem::MaybeUninit<D>; N],
        ) {
            for idx in 0..init {
                let mut element = &mut data[idx];

                // SAFETY:
                // - the caller must guarantee that the first `init` elements are initialized
                unsafe { element.assume_init_drop() }
            }
        }

        for idx in 0..N {
            #[cfg(feature = "std")]
            let result = {
                if !core::mem::needs_drop::<T::Output>() {
                    T::read_from(read, end_remaining)
                } else {
                    // this is unnecessary for soundness... but it's nice to not leak memory
                    match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
                        T::read_from(read, end_remaining)
                    })) {
                        Ok(res) => res,
                        Err(payload) => {
                            // SAFETY:
                            // - we would have initialized at least `idx` elements
                            unsafe { drop_initialized(idx, data) };

                            std::panic::resume_unwind(payload)
                        }
                    }
                }
            };

            #[cfg(not(feature = "std"))]
            let result = { T::read_from(read, end_remaining) };

            match result {
                Ok(inner) => {
                    // ptr to *uninitialized* data
                    let uninit_element_ptr = (&mut data[idx]).as_mut_ptr();

                    // SAFETY:
                    // - element_ptr has the correct alignment because it is derived from
                    //   MaybeUninit::uninit()
                    // - element_ptr is non-null for the same reason
                    // - it is safe to ptr::write to uninitialized data
                    unsafe {
                        core::ptr::write(uninit_element_ptr, inner);
                    }
                }
                Err(error) => {
                    if core::mem::needs_drop::<T::Output>() {
                        // SAFETY:
                        // - we would have initialized the first `idx` elements
                        unsafe { drop_initialized(idx, data) };
                    }

                    return Err(error);
                }
            }
        }

        // SAFETY:
        // - the entire array is initialized
        // - transmuting from [MaybeUninit<T>; N] to [T; N] is valid because MaybeUninit<T> has the
        //   same layout as T
        let transmuted_result: [T::Output; N] =
            unsafe { core::ptr::read(data.as_ptr().cast::<[T::Output; N]>()) };

        Ok(transmuted_result)
    }
}

impl<const N: usize, T> ProtocolWrite for [T; N]
where
    T: ProtocolWrite,
{
    fn write_to<B: BufMut + ?Sized>(&self, write: &mut B) -> usize {
        let mut sum = 0;
        for element in self.iter() {
            sum += element.write_to(write);
        }

        sum
    }

    fn len(&self) -> usize {
        self.iter().map(ProtocolWrite::len).sum()
    }
}

impl<const N: usize> ProtocolRead for [u8; N] {
    type Output = [u8; N];

    fn read_from<B: Buf + ?Sized>(read: &mut B, _: usize) -> Result<Self::Output> {
        let mut out = [0; N];
        read.try_copy_to_slice(&mut out[..])?;

        Ok(out)
    }
}

impl<const N: usize> ProtocolWrite for [u8; N] {
    fn write_to<B: BufMut + ?Sized>(&self, write: &mut B) -> usize {
        write.put_slice(&self[..]);
        self.len()
    }

    fn len(&self) -> usize {
        <[u8]>::len(&self[..])
    }
}

impl<T> ProtocolWrite for &T
where
    T: ProtocolWrite + ?Sized,
{
    fn write_to<B: BufMut + ?Sized>(&self, write: &mut B) -> usize {
        T::write_to(self, write)
    }

    fn len(&self) -> usize {
        T::len(self)
    }
}

impl<T> ProtocolWrite for &mut T
where
    T: ProtocolWrite + ?Sized,
{
    fn write_to<B: BufMut + ?Sized>(&self, write: &mut B) -> usize {
        T::write_to(self, write)
    }

    fn len(&self) -> usize {
        T::len(self)
    }
}

#[cfg(test)]
mod tests {
    use crate::types::{VarInt, VarLong, MAX_STRING_LENGTH, MAX_VAR_INT_BYTES, MAX_VAR_LONG_BYTES};
    use crate::{util, ProtocolRead, ProtocolWrite};
    use alloc::borrow::Cow;
    use alloc::string::String;
    use alloc::vec;
    use alloc::vec::Vec;

    macro_rules! var_len_test {
        ( $name:ident, $bytes:expr, $u_val:ty, $s_val:ty, $var_type:ty ) => {
            #[test]
            fn $name() {
                let mut buffer = [0u8; $bytes];

                const ALL_SET: $u_val = <$u_val>::MAX;
                const RANGE: $u_val = 10000;

                for i in 0..=<$u_val>::BITS {
                    let value = if i == 0 {
                        0
                    } else {
                        ALL_SET >> (<$u_val>::BITS - i)
                    };

                    // examine a range of values around where our # of leading zeroes changes
                    // this heuristic is made to catch bugs with our current length algorithm!
                    for s in value.saturating_sub(RANGE)..value.saturating_add(RANGE) {
                        let var_out = <$var_type>::from(s as $s_val);
                        let bytes_written = var_out.write_to(&mut &mut buffer[..]);
                        let var_in =
                            <$var_type>::read_from(&mut &buffer[..], 0).expect("read must succeed");

                        // count all non-zero bytes in the buffer
                        let non_zero_bytes = buffer.iter().filter(|val| **val != 0).count();

                        if s != 0 {
                            // when writing a nonzero value: bytes_written must == non_zero_bytes
                            assert_eq!(
                                bytes_written, non_zero_bytes,
                                "bytes_written != non_zero_bytes for {}",
                                s
                            );
                        } else {
                            // we write exactly 1 byte to represent zero
                            assert_eq!(bytes_written, 1, "{}", s);
                        }

                        assert_eq!(
                            bytes_written,
                            var_out.len(),
                            "bytes_written != out for {}",
                            s
                        );
                        assert_eq!(bytes_written, var_in.len(), "bytes_written != in for {}", s);
                        assert_eq!(*var_in, *var_out, "in != out for {}", s);

                        // zero our buffer for the next iteration
                        buffer.iter_mut().for_each(|b| *b = 0);
                    }
                }
            }
        };
    }

    var_len_test!(var_int_len, MAX_VAR_INT_BYTES, u32, i32, VarInt);
    var_len_test!(var_long_len, MAX_VAR_LONG_BYTES, u64, i64, VarLong);

    #[allow(dead_code)]
    fn type_check() {
        let mut out = Vec::<u8>::new();
        let vec = vec![0u8; 42];

        vec.write_to(&mut &mut out[..]);

        let cow: Cow<[u8]> = Cow::Owned(vec);
        cow.write_to(&mut &mut out[..]);

        let mut out = Vec::<u8>::new();

        let string = String::new();
        string.write_to(&mut out);
    }

    #[test]
    fn string_round_trip() {
        static SUS: &str = r#"
        I 🍆 play Minecraft ⛏ with a smile for hours at a time
        Stare at 👨🥜👜 my diamonds 💎💎💎 while relaxin' at my base tonight
        And when 👨❓🥵 they ask me what I'm 😱 scared of
        I say, 🐶💅 "Herobrine"
        (And when 👨❓🥵 they ask me what I'm scared of
        I say, 🐶💅 "Herobrine")"#;

        let mut out = Vec::new();
        let len = SUS.write_to(&mut out);

        let result = str::read_from(&mut &out[..], 0).expect("read must succeed");

        let target_len = SUS.len() + util::var_int_len(SUS.len() as i32);

        assert_eq!(SUS, result);
        assert_eq!(target_len, len);
    }

    #[test]
    fn array_round_trip() {
        let bytes = vec![42u8; 42];

        let mut out = Vec::new();
        bytes.write_to(&mut out);

        assert_eq!(out[1..], bytes);

        let reconstructed = <[u8]>::read_from(&mut &out[..], 0).expect("read must succeed");
        assert_eq!(bytes, reconstructed);
    }

    #[test]
    fn string_length_limit_respected() {
        // 💎 takes up multiple bytes, so we go way over the limit
        let big_string = "💎".repeat(MAX_STRING_LENGTH as usize);

        let mut out = Vec::new();
        big_string.write_to(&mut out);

        let result = str::read_from(&mut &out[..], 0);
        assert!(result.is_err());
    }
}
