{
  "id": 769,
  "packet_type_spec": {
    "boolean": "::yarms_protocol::types::Boolean",
    "byte": "::yarms_protocol::types::Byte",
    "byte_enum": "::yarms_protocol::types::Byte",
    "double": "::yarms_protocol::types::Double",
    "float": "::yarms_protocol::types::Float",
    "identifier": "::alloc::borrow::Cow<'a, ::yarms_identifier::Identifier>",
    "int": "::yarms_protocol::types::Int",
    "long": "::yarms_protocol::types::Long",
    "prefixed_array_of_byte": "::alloc::borrow::Cow<'a, [u8]>",
    "prefixed_array_of_identifier": "::alloc::borrow::Cow<'a, [::yarms_identifier::Identifier]>",
    "prefixed_array_of_login_property": "::alloc::borrow::Cow<'a, [super::data::LoginProperty<'b>]>",
    "prefixed_array_of_long": "::alloc::borrow::Cow<'a, [::yarms_protocol::types::Long]>",
    "prefixed_array_of_string": "::alloc::borrow::Cow<'a, [::alloc::string::String]>",
    "prefixed_array_of_uuid": "::alloc::borrow::Cow<'a, [::yarms_protocol::types::Uuid]>",
    "prefixed_array_of_varint": "::alloc::borrow::Cow<'a, [::yarms_protocol::types::VarInt]>",
    "prefixed_array_of_varlong": "::alloc::borrow::Cow<'a, [::yarms_protocol::types::VarLong]>",
    "prefixed_optional_identifier": "Option<::alloc::borrow::Cow<'a, ::yarms_identifier::Identifier>>",
    "prefixed_optional_prefixed_array_of_byte": "::core::option::Option<::alloc::borrow::Cow<'a, [u8]>>",
    "prefixed_optional_remaining_byte_array": "::core::option::Option<::yarms_protocol::types::RemainingByteArray<'a>>",
    "prefixed_optional_string": "::core::option::Option<::alloc::borrow::Cow<'a, str>>",
    "prefixed_optional_uuid": "::core::option::Option<::yarms_protocol::types::Uuid>",
    "prefixed_optional_varint": "::core::option::Option<::yarms_protocol::types::VarInt>",
    "remaining_byte_array": "::yarms_protocol::types::RemainingByteArray<'a>",
    "short": "::yarms_protocol::types::Short",
    "string": "::alloc::borrow::Cow<'a, str>",
    "unsigned_byte": "::yarms_protocol::types::UnsignedByte",
    "unsigned_byte_enum": "::yarms_protocol::types::UnsignedByte",
    "unsigned_short": "::yarms_protocol::types::UnsignedShort",
    "uuid": "::yarms_protocol::types::Uuid",
    "varint": "::yarms_protocol::types::VarInt",
    "varint_enum": "::yarms_protocol::types::VarInt",
    "varlong": "::yarms_protocol::types::VarLong"
  },
  "packet": [
    {
      "name": "ConfigurationClientInformation",
      "resource": "client_information",
      "doc": "Sent when the player connects, or when settings are changed.",
      "packet_id": 0,
      "state": "Configuration",
      "clientbound": false,
      "fields": [
        {
          "name": "locale",
          "doc": "e.g. en_GB.",
          "protocol_type": "string"
        },
        {
          "name": "view_distance",
          "doc": "Client-side render distance, in chunks.",
          "protocol_type": "byte"
        },
        {
          "name": "chat_mode",
          "doc": "0: enabled, 1: commands only, 2: hidden. See Chat#Client chat mode for more information.",
          "protocol_type": "varint_enum"
        },
        {
          "name": "chat_colors",
          "doc": "“Colors” multiplayer setting. The vanilla server stores this value but does nothing with it (see MC-64867). Third-party servers such as Hypixel disable all coloring in chat and system messages when it is false.",
          "protocol_type": "boolean"
        },
        {
          "name": "displayed_skin_parts",
          "doc": "Bit mask, see below.",
          "protocol_type": "unsigned_byte"
        },
        {
          "name": "main_hand",
          "doc": "0: Left, 1: Right.",
          "protocol_type": "varint_enum"
        },
        {
          "name": "enable_text_filtering",
          "doc": "Enables filtering of text on signs and written book titles. The vanilla client sets this according to the profanityFilterPreferences.profanityFilterOn account attribute indicated by the/player/attributes Mojang API endpoint. In offline mode it is always false.",
          "protocol_type": "boolean"
        },
        {
          "name": "allow_server_listings",
          "doc": "Servers usually list online players, this option should let you not show up in that list.",
          "protocol_type": "boolean"
        },
        {
          "name": "particle_status",
          "doc": "0: all, 1: decreased, 2: minimal",
          "protocol_type": "varint_enum"
        }
      ]
    },
    {
      "name": "ConfigurationCookieResponse",
      "resource": "cookie_response",
      "doc": "Response to a Cookie Request (configuration) from the server. The vanilla server only accepts responses of up to 5 kiB in size.",
      "packet_id": 1,
      "state": "Configuration",
      "clientbound": false,
      "fields": [
        {
          "name": "key",
          "doc": "The identifier of the cookie.",
          "protocol_type": "identifier"
        },
        {
          "name": "payload",
          "doc": "The data of the cookie.",
          "protocol_type": "prefixed_optional_prefixed_array_of_byte"
        }
      ]
    },
    {
      "name": "ConfigurationServerboundPluginMessage",
      "resource": "custom_payload",
      "doc": "Main page: Minecraft Wiki:Projects/wiki.vg merge/Plugin channels\n\nMods and plugins can use this to send their data. Minecraft itself uses some plugin channels. These internal channels are in the minecraft namespace.\n\nMore documentation on this: https://dinnerbone.com/blog/2012/01/13/minecraft-plugin-channels-messaging/\n\nNote that the length of Data is known only from the packet length, since the packet has no length field of any kind.",
      "packet_id": 2,
      "state": "Configuration",
      "clientbound": false,
      "fields": [
        {
          "name": "channel",
          "doc": "Name of the plugin channel used to send the data.",
          "protocol_type": "identifier"
        },
        {
          "name": "data",
          "doc": "Any data, depending on the channel. minecraft: channels are documented here. The length of this array must be inferred from the packet length.",
          "protocol_type": "remaining_byte_array"
        }
      ]
    },
    {
      "name": "AcknowledgeFinishConfiguration",
      "resource": "finish_configuration",
      "doc": "Sent by the client to notify the server that the configuration process has finished. It is sent in response to the server's Finish Configuration.",
      "packet_id": 3,
      "state": "Configuration",
      "clientbound": false,
      "fields": []
    },
    {
      "name": "ConfigurationServerboundKeepAlive",
      "resource": "keep_alive",
      "doc": "The server will frequently send out a keep-alive (see Clientbound Keep Alive), each containing a random ID. The client must respond with the same packet.",
      "packet_id": 4,
      "state": "Configuration",
      "clientbound": false,
      "fields": [
        {
          "name": "keep_alive_id",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "long"
        }
      ]
    },
    {
      "name": "ConfigurationPong",
      "resource": "pong",
      "doc": "Response to the clientbound packet (Ping) with the same id.",
      "packet_id": 5,
      "state": "Configuration",
      "clientbound": false,
      "fields": [
        {
          "name": "id",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "int"
        }
      ]
    },
    {
      "name": "ConfigurationResourcePackResponse",
      "resource": "resource_pack",
      "doc": "Documentation is missing for this packet.",
      "packet_id": 6,
      "state": "Configuration",
      "clientbound": false,
      "fields": [
        {
          "name": "uuid",
          "doc": "The unique identifier of the resource pack received in the Add Resource Pack (configuration) request.",
          "protocol_type": "uuid"
        },
        {
          "name": "result",
          "doc": "Result ID (see below).",
          "protocol_type": "varint_enum"
        }
      ]
    },
    {
      "name": "ServerboundKnownPacks",
      "resource": "select_known_packs",
      "doc": "Informs the server of which data packs are present on the client. The client sends this in response to Clientbound Known Packs.\n\nIf the client specifies a pack in this packet, the server should omit its contained data from the Registry Data packet.",
      "packet_id": 7,
      "state": "Configuration",
      "clientbound": false,
      "fields": []
    },
    {
      "name": "ConfigurationCookieRequest",
      "resource": "cookie_request",
      "doc": "Requests a cookie that was previously stored.",
      "packet_id": 0,
      "state": "Configuration",
      "clientbound": true,
      "fields": [
        {
          "name": "key",
          "doc": "The identifier of the cookie.",
          "protocol_type": "identifier"
        }
      ]
    },
    {
      "name": "ConfigurationClientboundPluginMessage",
      "resource": "custom_payload",
      "doc": "Main page: Minecraft Wiki:Projects/wiki.vg merge/Plugin channels\n\nMods and plugins can use this to send their data. Minecraft itself uses several plugin channels. These internal channels are in the minecraft namespace.\n\nMore information on how it works on Dinnerbone's blog. More documentation about internal and popular registered channels are here.",
      "packet_id": 1,
      "state": "Configuration",
      "clientbound": true,
      "fields": [
        {
          "name": "channel",
          "doc": "Name of the plugin channel used to send the data.",
          "protocol_type": "identifier"
        },
        {
          "name": "data",
          "doc": "Any data. The length of this array must be inferred from the packet length.",
          "protocol_type": "remaining_byte_array"
        }
      ]
    },
    {
      "name": "ConfigurationDisconnect",
      "resource": "disconnect",
      "doc": "Documentation is missing for this packet.",
      "packet_id": 2,
      "state": "Configuration",
      "clientbound": true,
      "fields": [
        {
          "name": "reason",
          "doc": "The reason why the player was disconnected.",
          "protocol_type": "text_component"
        }
      ]
    },
    {
      "name": "FinishConfiguration",
      "resource": "finish_configuration",
      "doc": "Sent by the server to notify the client that the configuration process has finished. The client answers with Acknowledge Finish Configuration whenever it is ready to continue.",
      "packet_id": 3,
      "state": "Configuration",
      "clientbound": true,
      "fields": []
    },
    {
      "name": "ConfigurationClientboundKeepAlive",
      "resource": "keep_alive",
      "doc": "The server will frequently send out a keep-alive, each containing a random ID. The client must respond with the same payload (see Serverbound Keep Alive). If the client does not respond to a Keep Alive packet within 15 seconds after it was sent, the server kicks the client. Vice versa, if the server does not send any keep-alives for 20 seconds, the client will disconnect and yields a \"Timed out\" exception.\n\nThe vanilla server uses a system-dependent time in milliseconds to generate the keep alive ID value.",
      "packet_id": 4,
      "state": "Configuration",
      "clientbound": true,
      "fields": [
        {
          "name": "keep_alive_id",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "long"
        }
      ]
    },
    {
      "name": "ConfigurationPing",
      "resource": "ping",
      "doc": "Packet is not used by the vanilla server. When sent to the client, client responds with a Pong packet with the same id.",
      "packet_id": 5,
      "state": "Configuration",
      "clientbound": true,
      "fields": [
        {
          "name": "id",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "int"
        }
      ]
    },
    {
      "name": "ResetChat",
      "resource": "reset_chat",
      "doc": "Documentation is missing for this packet.",
      "packet_id": 6,
      "state": "Configuration",
      "clientbound": true,
      "fields": []
    },
    {
      "name": "RegistryData",
      "resource": "registry_data",
      "doc": "Represents certain registries that are sent from the server and are applied on the client.\n\nSee Registry Data for details.",
      "packet_id": 7,
      "state": "Configuration",
      "clientbound": true,
      "fields": []
    },
    {
      "name": "ConfigurationRemoveResourcePack",
      "resource": "resource_pack_pop",
      "doc": "Documentation is missing for this packet.",
      "packet_id": 8,
      "state": "Configuration",
      "clientbound": true,
      "fields": [
        {
          "name": "uuid",
          "doc": "The UUID of the resource pack to be removed. If not present every resource pack will be removed.",
          "protocol_type": "prefixed_optional_uuid"
        }
      ]
    },
    {
      "name": "ConfigurationAddResourcePack",
      "resource": "resource_pack_push",
      "doc": "Documentation is missing for this packet.",
      "packet_id": 9,
      "state": "Configuration",
      "clientbound": true,
      "fields": [
        {
          "name": "uuid",
          "doc": "The unique identifier of the resource pack.",
          "protocol_type": "uuid"
        },
        {
          "name": "url",
          "doc": "The URL to the resource pack.",
          "protocol_type": "string"
        },
        {
          "name": "hash",
          "doc": "A 40 character hexadecimal, case-insensitive SHA-1 hash of the resource pack file. If it's not a 40 character hexadecimal string, the client will not use it for hash verification and likely waste bandwidth.",
          "protocol_type": "string"
        },
        {
          "name": "forced",
          "doc": "The vanilla client will be forced to use the resource pack from the server. If they decline they will be kicked from the server.",
          "protocol_type": "boolean"
        },
        {
          "name": "prompt_message",
          "doc": "This is shown in the prompt making the client accept or decline the resource pack (only if present).",
          "protocol_type": "prefixed_optional_text_component"
        }
      ]
    },
    {
      "name": "ConfigurationStoreCookie",
      "resource": "store_cookie",
      "doc": "Stores some arbitrary data on the client, which persists between server transfers. The vanilla client only accepts cookies of up to 5 kiB in size.",
      "packet_id": 10,
      "state": "Configuration",
      "clientbound": true,
      "fields": [
        {
          "name": "key",
          "doc": "The identifier of the cookie.",
          "protocol_type": "identifier"
        },
        {
          "name": "payload",
          "doc": "The data of the cookie.",
          "protocol_type": "prefixed_array_of_byte"
        }
      ]
    },
    {
      "name": "ConfigurationTransfer",
      "resource": "transfer",
      "doc": "Notifies the client that it should transfer to the given server. Cookies previously stored are preserved between server transfers.",
      "packet_id": 11,
      "state": "Configuration",
      "clientbound": true,
      "fields": [
        {
          "name": "host",
          "doc": "The hostname or IP of the server.",
          "protocol_type": "string"
        },
        {
          "name": "port",
          "doc": "The port of the server.",
          "protocol_type": "varint"
        }
      ]
    },
    {
      "name": "FeatureFlags",
      "resource": "update_enabled_features",
      "doc": "Used to enable and disable features, generally experimental ones, on the client.",
      "packet_id": 12,
      "state": "Configuration",
      "clientbound": true,
      "fields": [
        {
          "name": "feature_flags",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "prefixed_array_of_identifier"
        }
      ]
    },
    {
      "name": "ConfigurationUpdateTags",
      "resource": "update_tags",
      "doc": "Documentation is missing for this packet.",
      "packet_id": 13,
      "state": "Configuration",
      "clientbound": true,
      "fields": []
    },
    {
      "name": "ClientboundKnownPacks",
      "resource": "select_known_packs",
      "doc": "Informs the client of which data packs are present on the server. The client is expected to respond with its own Serverbound Known Packs packet. The vanilla server does not continue with Configuration until it receives a response.\n\nThe vanilla client requires the minecraft:core pack with version 1.21.4 for a normal login sequence. This packet must be sent before the Registry Data packets.",
      "packet_id": 14,
      "state": "Configuration",
      "clientbound": true,
      "fields": []
    },
    {
      "name": "ConfigurationCustomReportDetails",
      "resource": "custom_report_details",
      "doc": "Contains a list of key-value text entries that are included in any crash or disconnection report generated during connection to the server.",
      "packet_id": 15,
      "state": "Configuration",
      "clientbound": true,
      "fields": []
    },
    {
      "name": "ConfigurationServerLinks",
      "resource": "server_links",
      "doc": "This packet contains a list of links that the vanilla client will display in the menu available from the pause menu. Link labels can be built-in or custom (i.e., any text).",
      "packet_id": 16,
      "state": "Configuration",
      "clientbound": true,
      "fields": []
    },
    {
      "name": "Handshake",
      "resource": "intention",
      "doc": "This packet causes the server to switch into the target state. It should be sent right after opening the TCP connection to prevent the server from disconnecting.",
      "packet_id": 0,
      "state": "Handshaking",
      "clientbound": false,
      "fields": [
        {
          "name": "protocol_version",
          "doc": "See protocol version numbers (currently 769 in Minecraft 1.21.4).",
          "protocol_type": "varint"
        },
        {
          "name": "server_address",
          "doc": "Hostname or IP, e.g. localhost or 127.0.0.1, that was used to connect. The vanilla server does not use this information. Note that SRV records are a simple redirect, e.g. if_minecraft._tcp.example.com points to mc.example.org, users connecting to example.com will provide example.org as server address in addition to connecting to it.",
          "protocol_type": "string"
        },
        {
          "name": "server_port",
          "doc": "Default is 25565. The vanilla server does not use this information.",
          "protocol_type": "unsigned_short"
        },
        {
          "name": "next_state",
          "doc": "1 for Status, 2 for Login, 3 for Transfer.",
          "protocol_type": "varint_enum"
        }
      ]
    },
    {
      "name": "LoginStart",
      "resource": "hello",
      "doc": "Documentation is missing for this packet.",
      "packet_id": 0,
      "state": "Login",
      "clientbound": false,
      "fields": [
        {
          "name": "name",
          "doc": "Player's Username.",
          "protocol_type": "string"
        },
        {
          "name": "player_uuid",
          "doc": "The UUID of the player logging in. Unused by the vanilla server.",
          "protocol_type": "uuid"
        }
      ]
    },
    {
      "name": "EncryptionResponse",
      "resource": "key",
      "doc": "Documentation is missing for this packet.",
      "packet_id": 1,
      "state": "Login",
      "clientbound": false,
      "fields": [
        {
          "name": "shared_secret",
          "doc": "Shared Secret value, encrypted with the server's public key.",
          "protocol_type": "prefixed_array_of_byte"
        },
        {
          "name": "verify_token",
          "doc": "Verify Token value, encrypted with the same public key as the shared secret.",
          "protocol_type": "prefixed_array_of_byte"
        }
      ]
    },
    {
      "name": "LoginPluginResponse",
      "resource": "custom_query_answer",
      "doc": "Documentation is missing for this packet.",
      "packet_id": 2,
      "state": "Login",
      "clientbound": false,
      "fields": [
        {
          "name": "message_id",
          "doc": "Should match ID from server.",
          "protocol_type": "varint"
        },
        {
          "name": "data",
          "doc": "Any data, depending on the channel. The length of this array must be inferred from the packet length. Only present if the client understood the request.",
          "protocol_type": "prefixed_optional_remaining_byte_array"
        }
      ]
    },
    {
      "name": "LoginAcknowledged",
      "resource": "login_acknowledged",
      "doc": "Acknowledgement to the Login Success packet sent by the server.",
      "packet_id": 3,
      "state": "Login",
      "clientbound": false,
      "fields": []
    },
    {
      "name": "LoginCookieResponse",
      "resource": "cookie_response",
      "doc": "Response to a Cookie Request (login) from the server. The vanilla server only accepts responses of up to 5 kiB in size.",
      "packet_id": 4,
      "state": "Login",
      "clientbound": false,
      "fields": [
        {
          "name": "key",
          "doc": "The identifier of the cookie.",
          "protocol_type": "identifier"
        },
        {
          "name": "payload",
          "doc": "The data of the cookie.",
          "protocol_type": "prefixed_optional_prefixed_array_of_byte"
        }
      ]
    },
    {
      "name": "LoginDisconnect",
      "resource": "login_disconnect",
      "doc": "Documentation is missing for this packet.",
      "packet_id": 0,
      "state": "Login",
      "clientbound": true,
      "fields": [
        {
          "name": "reason",
          "doc": "The reason why the player was disconnected.",
          "protocol_type": "json_text_component"
        }
      ]
    },
    {
      "name": "EncryptionRequest",
      "resource": "hello",
      "doc": "Documentation is missing for this packet.",
      "packet_id": 1,
      "state": "Login",
      "clientbound": true,
      "fields": [
        {
          "name": "server_id",
          "doc": "Always empty when sent by the vanilla server.",
          "protocol_type": "string"
        },
        {
          "name": "public_key",
          "doc": "The server's public key, in bytes.",
          "protocol_type": "prefixed_array_of_byte"
        },
        {
          "name": "verify_token",
          "doc": "A sequence of random bytes generated by the server.",
          "protocol_type": "prefixed_array_of_byte"
        },
        {
          "name": "should_authenticate",
          "doc": "Whether the client should attempt to authenticate through mojang servers.",
          "protocol_type": "boolean"
        }
      ]
    },
    {
      "name": "LoginSuccess",
      "resource": "login_finished",
      "doc": "Documentation is missing for this packet.",
      "packet_id": 2,
      "state": "Login",
      "clientbound": true,
      "fields": [
        {
          "name": "uuid",
          "doc": "",
          "protocol_type": "uuid"
        },
        {
          "name": "username",
          "doc": "",
          "protocol_type": "string"
        },
        {
          "name": "properties",
          "doc": "",
          "protocol_type": "prefixed_array_of_login_property"
        }
      ]
    },
    {
      "name": "SetCompression",
      "resource": "login_compression",
      "doc": "Enables compression. If compression is enabled, all following packets are encoded in the compressed packet format. Negative values will disable compression, meaning the packet format should remain in the uncompressed packet format. However, this packet is entirely optional, and if not sent, compression will also not be enabled (the vanilla server does not send the packet when compression is disabled).",
      "packet_id": 3,
      "state": "Login",
      "clientbound": true,
      "fields": [
        {
          "name": "threshold",
          "doc": "Maximum size of a packet before it is compressed.",
          "protocol_type": "varint"
        }
      ]
    },
    {
      "name": "LoginPluginRequest",
      "resource": "custom_query",
      "doc": "Used to implement a custom handshaking flow together with Login Plugin Response.\n\nUnlike plugin messages in \"play\" mode, these messages follow a lock-step request/response scheme, where the client is expected to respond to a request indicating whether it understood. The vanilla client always responds that it hasn't understood, and sends an empty payload.",
      "packet_id": 4,
      "state": "Login",
      "clientbound": true,
      "fields": [
        {
          "name": "message_id",
          "doc": "Generated by the server - should be unique to the connection.",
          "protocol_type": "varint"
        },
        {
          "name": "channel",
          "doc": "Name of the plugin channel used to send the data.",
          "protocol_type": "identifier"
        },
        {
          "name": "data",
          "doc": "Any data, depending on the channel. The length of this array must be inferred from the packet length.",
          "protocol_type": "remaining_byte_array"
        }
      ]
    },
    {
      "name": "LoginCookieRequest",
      "resource": "cookie_request",
      "doc": "Requests a cookie that was previously stored.",
      "packet_id": 5,
      "state": "Login",
      "clientbound": true,
      "fields": [
        {
          "name": "key",
          "doc": "The identifier of the cookie.",
          "protocol_type": "identifier"
        }
      ]
    },
    {
      "name": "ConfirmTeleportation",
      "resource": "accept_teleportation",
      "doc": "Sent by client as confirmation of Synchronize Player Position.",
      "packet_id": 0,
      "state": "Play",
      "clientbound": false,
      "fields": [
        {
          "name": "teleport_id",
          "doc": "The ID given by the Synchronize Player Position packet.",
          "protocol_type": "varint"
        }
      ]
    },
    {
      "name": "QueryBlockEntityTag",
      "resource": "block_entity_tag_query",
      "doc": "Used when F3 + I is pressed while looking at a block.",
      "packet_id": 1,
      "state": "Play",
      "clientbound": false,
      "fields": [
        {
          "name": "transaction_id",
          "doc": "An incremental ID so that the client can verify that the response matches.",
          "protocol_type": "varint"
        },
        {
          "name": "location",
          "doc": "The location of the block to check.",
          "protocol_type": "position"
        }
      ]
    },
    {
      "name": "BundleItemSelected",
      "resource": "bundle_item_selected",
      "doc": "Documentation is missing for this packet.",
      "packet_id": 2,
      "state": "Play",
      "clientbound": false,
      "fields": [
        {
          "name": "slot_of_bundle",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "varint"
        },
        {
          "name": "slot_in_bundle",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "varint"
        }
      ]
    },
    {
      "name": "ChangeDifficulty",
      "resource": "change_difficulty",
      "doc": "Must have at least op level 2 to use. Appears to only be used on singleplayer; the difficulty buttons are still disabled in multiplayer.",
      "packet_id": 3,
      "state": "Play",
      "clientbound": false,
      "fields": [
        {
          "name": "new_difficulty",
          "doc": "0: peaceful, 1: easy, 2: normal, 3: hard.",
          "protocol_type": "unsigned_byte_enum"
        }
      ]
    },
    {
      "name": "AcknowledgeMessage",
      "resource": "chat_ack",
      "doc": "Documentation is missing for this packet.",
      "packet_id": 4,
      "state": "Play",
      "clientbound": false,
      "fields": [
        {
          "name": "message_count",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "varint"
        }
      ]
    },
    {
      "name": "ChatCommand",
      "resource": "chat_command",
      "doc": "Main article: Chat",
      "packet_id": 5,
      "state": "Play",
      "clientbound": false,
      "fields": [
        {
          "name": "command",
          "doc": "The command typed by the client.",
          "protocol_type": "string"
        }
      ]
    },
    {
      "name": "SignedChatCommand",
      "resource": "chat_command_signed",
      "doc": "Main article: Chat",
      "packet_id": 6,
      "state": "Play",
      "clientbound": false,
      "fields": []
    },
    {
      "name": "ChatMessage",
      "resource": "chat",
      "doc": "Main article: Chat\n\nUsed to send a chat message to the server. The message may not be longer than 256 characters or else the server will kick the client.\n\nThe server will broadcast a Player Chat Message packet with Chat Type minecraft:chat to all players that haven't disabled chat (including the player that sent the message). See Chat#Processing chat for more information.",
      "packet_id": 7,
      "state": "Play",
      "clientbound": false,
      "fields": [
        {
          "name": "message",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "string"
        },
        {
          "name": "timestamp",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "long"
        },
        {
          "name": "salt",
          "doc": "The salt used to verify the signature hash.",
          "protocol_type": "long"
        },
        {
          "name": "signature",
          "doc": "The signature used to verify the chat message's authentication. When present, always 256 bytes and not length-prefixed.",
          "protocol_type": "prefixed_optional_byte_array"
        },
        {
          "name": "message_count",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "varint"
        },
        {
          "name": "acknowledged",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "fixed_bitset"
        }
      ]
    },
    {
      "name": "PlayerSession",
      "resource": "chat_session_update",
      "doc": "Documentation is missing for this packet.",
      "packet_id": 8,
      "state": "Play",
      "clientbound": false,
      "fields": []
    },
    {
      "name": "ChunkBatchReceived",
      "resource": "chunk_batch_received",
      "doc": "Notifies the server that the chunk batch has been received by the client. The server uses the value sent in this packet to adjust the number of chunks to be sent in a batch.\n\nThe vanilla server will stop sending further chunk data until the client acknowledges the sent chunk batch. After the first acknowledgement, the server adjusts this number to allow up to 10 unacknowledged batches.",
      "packet_id": 9,
      "state": "Play",
      "clientbound": false,
      "fields": [
        {
          "name": "chunks_per_tick",
          "doc": "Desired chunks per tick.",
          "protocol_type": "float"
        }
      ]
    },
    {
      "name": "ClientStatus",
      "resource": "client_command",
      "doc": "Documentation is missing for this packet.",
      "packet_id": 10,
      "state": "Play",
      "clientbound": false,
      "fields": [
        {
          "name": "action_id",
          "doc": "See below",
          "protocol_type": "varint_enum"
        }
      ]
    },
    {
      "name": "ClientTickEnd",
      "resource": "client_tick_end",
      "doc": "Documentation is missing for this packet.",
      "packet_id": 11,
      "state": "Play",
      "clientbound": false,
      "fields": []
    },
    {
      "name": "PlayClientInformation",
      "resource": "client_information",
      "doc": "Sent when the player connects, or when settings are changed.",
      "packet_id": 12,
      "state": "Play",
      "clientbound": false,
      "fields": [
        {
          "name": "locale",
          "doc": "e.g. en_GB.",
          "protocol_type": "string"
        },
        {
          "name": "view_distance",
          "doc": "Client-side render distance, in chunks.",
          "protocol_type": "byte"
        },
        {
          "name": "chat_mode",
          "doc": "0: enabled, 1: commands only, 2: hidden. See Chat#Client chat mode for more information.",
          "protocol_type": "varint_enum"
        },
        {
          "name": "chat_colors",
          "doc": "“Colors” multiplayer setting. The vanilla server stores this value but does nothing with it (see MC-64867). Third-party servers such as Hypixel disable all coloring in chat and system messages when it is false.",
          "protocol_type": "boolean"
        },
        {
          "name": "displayed_skin_parts",
          "doc": "Bit mask, see below.",
          "protocol_type": "unsigned_byte"
        },
        {
          "name": "main_hand",
          "doc": "0: Left, 1: Right.",
          "protocol_type": "varint_enum"
        },
        {
          "name": "enable_text_filtering",
          "doc": "Enables filtering of text on signs and written book titles. The vanilla client sets this according to the profanityFilterPreferences.profanityFilterOn account attribute indicated by the/player/attributes Mojang API endpoint. In offline mode it is always false.",
          "protocol_type": "boolean"
        },
        {
          "name": "allow_server_listings",
          "doc": "Servers usually list online players, this option should let you not show up in that list.",
          "protocol_type": "boolean"
        },
        {
          "name": "particle_status",
          "doc": "0: all, 1: decreased, 2: minimal",
          "protocol_type": "varint_enum"
        }
      ]
    },
    {
      "name": "CommandSuggestionsRequest",
      "resource": "command_suggestion",
      "doc": "Sent when the client needs to tab-complete a minecraft:ask_server suggestion type.",
      "packet_id": 13,
      "state": "Play",
      "clientbound": false,
      "fields": [
        {
          "name": "transaction_id",
          "doc": "The id of the transaction that the server will send back to the client in the response of this packet. Client generates this and increments it each time it sends another tab completion that doesn't get a response.",
          "protocol_type": "varint"
        },
        {
          "name": "text",
          "doc": "All text behind the cursor without the/ (e.g. to the left of the cursor in left-to-right languages like English).",
          "protocol_type": "string"
        }
      ]
    },
    {
      "name": "AcknowledgeConfiguration",
      "resource": "configuration_acknowledged",
      "doc": "Sent by the client upon receiving a Start Configuration packet from the server.",
      "packet_id": 14,
      "state": "Play",
      "clientbound": false,
      "fields": []
    },
    {
      "name": "ClickContainerButton",
      "resource": "container_button_click",
      "doc": "Used when clicking on window buttons. Until 1.14, this was only used by enchantment tables.",
      "packet_id": 15,
      "state": "Play",
      "clientbound": false,
      "fields": [
        {
          "name": "window_id",
          "doc": "The ID of the window sent by Open Screen.",
          "protocol_type": "varint"
        },
        {
          "name": "button_id",
          "doc": "Meaning depends on window type; see below.",
          "protocol_type": "varint"
        }
      ]
    },
    {
      "name": "ClickContainer",
      "resource": "container_click",
      "doc": "This packet is sent by the client when the player clicks on a slot in a window.",
      "packet_id": 16,
      "state": "Play",
      "clientbound": false,
      "fields": []
    },
    {
      "name": "CloseContainer",
      "resource": "container_close",
      "doc": "This packet is sent by the client when closing a window.\n\nvanilla clients send a Close Window packet with Window ID 0 to close their inventory even though there is never an Open Screen packet for the inventory.",
      "packet_id": 17,
      "state": "Play",
      "clientbound": false,
      "fields": [
        {
          "name": "window_id",
          "doc": "This is the ID of the window that was closed. 0 for player inventory.",
          "protocol_type": "varint"
        }
      ]
    },
    {
      "name": "ChangeContainerSlotState",
      "resource": "container_slot_state_changed",
      "doc": "This packet is sent by the client when toggling the state of a Crafter.",
      "packet_id": 18,
      "state": "Play",
      "clientbound": false,
      "fields": [
        {
          "name": "slot_id",
          "doc": "This is the ID of the slot that was changed.",
          "protocol_type": "varint"
        },
        {
          "name": "window_id",
          "doc": "This is the ID of the window that was changed.",
          "protocol_type": "varint"
        },
        {
          "name": "state",
          "doc": "The new state of the slot. True for enabled, false for disabled.",
          "protocol_type": "boolean"
        }
      ]
    },
    {
      "name": "PlayCookieResponse",
      "resource": "cookie_response",
      "doc": "Response to a Cookie Request (play) from the server. The vanilla server only accepts responses of up to 5 kiB in size.",
      "packet_id": 19,
      "state": "Play",
      "clientbound": false,
      "fields": [
        {
          "name": "key",
          "doc": "The identifier of the cookie.",
          "protocol_type": "identifier"
        },
        {
          "name": "payload",
          "doc": "The data of the cookie.",
          "protocol_type": "prefixed_optional_prefixed_array_of_byte"
        }
      ]
    },
    {
      "name": "PlayServerboundPluginMessage",
      "resource": "custom_payload",
      "doc": "Main page: Minecraft Wiki:Projects/wiki.vg merge/Plugin channels\n\nMods and plugins can use this to send their data. Minecraft itself uses some plugin channels. These internal channels are in the minecraft namespace.\n\nMore documentation on this: https://dinnerbone.com/blog/2012/01/13/minecraft-plugin-channels-messaging/\n\nNote that the length of Data is known only from the packet length, since the packet has no length field of any kind.",
      "packet_id": 20,
      "state": "Play",
      "clientbound": false,
      "fields": [
        {
          "name": "channel",
          "doc": "Name of the plugin channel used to send the data.",
          "protocol_type": "identifier"
        },
        {
          "name": "data",
          "doc": "Any data, depending on the channel. minecraft: channels are documented here. The length of this array must be inferred from the packet length.",
          "protocol_type": "remaining_byte_array"
        }
      ]
    },
    {
      "name": "DebugSampleSubscription",
      "resource": "debug_sample_subscription",
      "doc": "Subscribes to the specified type of debug sample data, which is then sent periodically to the client via Debug Sample.\n\nThe subscription is retained for 10 seconds (the vanilla server checks that both 10.001 real-time seconds and 201 ticks have elapsed), after which the client is automatically unsubscribed. The vanilla client resends this packet every 5 seconds to keep up the subscription.\n\nThe vanilla server only allows subscriptions from players that are server operators.",
      "packet_id": 21,
      "state": "Play",
      "clientbound": false,
      "fields": [
        {
          "name": "sample_type",
          "doc": "The type of debug sample to subscribe to. Can be one of the following: 0 - Tick time",
          "protocol_type": "varint_enum"
        }
      ]
    },
    {
      "name": "EditBook",
      "resource": "edit_book",
      "doc": "Documentation is missing for this packet.",
      "packet_id": 22,
      "state": "Play",
      "clientbound": false,
      "fields": [
        {
          "name": "slot",
          "doc": "The hotbar slot where the written book is located",
          "protocol_type": "varint"
        },
        {
          "name": "entries",
          "doc": "Text from each page. Maximum string length is 1024 chars.",
          "protocol_type": "prefixed_array_of_string"
        },
        {
          "name": "title",
          "doc": "Title of book. Present if book is being signed, not present if book is being edited.",
          "protocol_type": "prefixed_optional_string"
        }
      ]
    },
    {
      "name": "QueryEntityTag",
      "resource": "entity_tag_query",
      "doc": "Used when F3 + I is pressed while looking at an entity.",
      "packet_id": 23,
      "state": "Play",
      "clientbound": false,
      "fields": [
        {
          "name": "transaction_id",
          "doc": "An incremental ID so that the client can verify that the response matches.",
          "protocol_type": "varint"
        },
        {
          "name": "entity_id",
          "doc": "The ID of the entity to query.",
          "protocol_type": "varint"
        }
      ]
    },
    {
      "name": "Interact",
      "resource": "interact",
      "doc": "This packet is sent from the client to the server when the client attacks or right-clicks another entity (a player, minecart, etc).\n\nA vanilla server only accepts this packet if the entity being attacked/used is visible without obstruction and within a 4-unit radius of the player's position.\n\nThe target X, Y, and Z fields represent the difference between the vector location of the cursor at the time of the packet and the entity's position.\n\nNote that middle-click in creative mode is interpreted by the client and sent as a Set Creative Mode Slot packet instead.",
      "packet_id": 24,
      "state": "Play",
      "clientbound": false,
      "fields": [
        {
          "name": "entity_id",
          "doc": "The ID of the entity to interact. Note the special case described below.",
          "protocol_type": "varint"
        },
        {
          "name": "type",
          "doc": "0: interact, 1: attack, 2: interact at.",
          "protocol_type": "varint_enum"
        },
        {
          "name": "target_x",
          "doc": "Only if Type is interact at.",
          "protocol_type": "optional_float"
        },
        {
          "name": "target_y",
          "doc": "Only if Type is interact at.",
          "protocol_type": "optional_float"
        },
        {
          "name": "target_z",
          "doc": "Only if Type is interact at.",
          "protocol_type": "optional_float"
        },
        {
          "name": "hand",
          "doc": "Only if Type is interact or interact at; 0: main hand, 1: off hand.",
          "protocol_type": "optional_varint_enum"
        },
        {
          "name": "sneak_key_pressed",
          "doc": "If the client is pressing the sneak key. Has the same effect as a Player Command Press/Release sneak key preceding the interaction, and the state is permanently changed.",
          "protocol_type": "boolean"
        }
      ]
    },
    {
      "name": "JigsawGenerate",
      "resource": "jigsaw_generate",
      "doc": "Sent when Generate is pressed on the Jigsaw Block interface.",
      "packet_id": 25,
      "state": "Play",
      "clientbound": false,
      "fields": [
        {
          "name": "location",
          "doc": "Block entity location.",
          "protocol_type": "position"
        },
        {
          "name": "levels",
          "doc": "Value of the levels slider/max depth to generate.",
          "protocol_type": "varint"
        },
        {
          "name": "keep_jigsaws",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "boolean"
        }
      ]
    },
    {
      "name": "PlayServerboundKeepAlive",
      "resource": "keep_alive",
      "doc": "The server will frequently send out a keep-alive (see Clientbound Keep Alive), each containing a random ID. The client must respond with the same packet.",
      "packet_id": 26,
      "state": "Play",
      "clientbound": false,
      "fields": [
        {
          "name": "keep_alive_id",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "long"
        }
      ]
    },
    {
      "name": "LockDifficulty",
      "resource": "lock_difficulty",
      "doc": "Must have at least op level 2 to use. Appears to only be used on singleplayer; the difficulty buttons are still disabled in multiplayer.",
      "packet_id": 27,
      "state": "Play",
      "clientbound": false,
      "fields": [
        {
          "name": "locked",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "boolean"
        }
      ]
    },
    {
      "name": "SetPlayerPosition",
      "resource": "move_player_pos",
      "doc": "Updates the player's XYZ position on the server.\n\nIf the player is in a vehicle, the position is ignored (but in case of Set Player Position and Rotation, the rotation is still used as normal). No validation steps other than value range clamping are performed in this case.\n\nIf the player is sleeping, the position (or rotation) is not changed, and a Synchronize Player Position is sent if the received position deviated from the server's view by more than a meter.\n\nThe vanilla server silently clamps the x and z coordinates between -30,000,000 and 30,000,000, and the y coordinate between -20,000,000 and 20,000,000. A similar condition has historically caused a kick for \"Illegal position\"; this is no longer the case. However, infinite or NaN coordinates (or angles) still result in a kick for multiplayer.disconnect.invalid_player_movement.\n\nAs of 1.20.6, checking for moving too fast is achieved like this (sic):\n\nEach server tick, the player's current position is stored. When the player moves, the offset from the stored position to the requested position is computed (Δx, Δy, Δz). The requested movement distance squared is computed as Δx² + Δy² + Δz². The baseline expected movement distance squared is computed based on the player's server-side velocity as Vx² + Vy² + Vz². The player's server-side velocity is a somewhat ill-defined quantity that includes among other things gravity, jump velocity and knockback, but not regular horizontal movement. A proper description would bring much of Minecraft's physics engine with it. It is accessible as the Motion NBT tag on the player entity. The maximum permitted movement distance squared is computed as 100 (300 if the player is using an elytra), multiplied by the number of movement packets received since the last tick, including this one, unless that value is greater than 5, in which case no multiplier is applied. If the requested movement distance squared minus the baseline distance squared is more than the maximum squared, the player is moving too fast.\n\nIf the player is moving too fast, it is logged that \"<player> moved too quickly!\" followed by the change in x, y, and z, and the player is teleported back to their current (before this packet) server-side position.\n\nChecking for block collisions is achieved like this:\n\nA temporary collision-checked move of the player is attempted from its current position to the requested one. The offset from the resulting position to the requested position is computed. If the absolute value of the offset on the y axis is less than 0.5, it (only the y component) is rounded down to 0. If the magnitude of the offset is greater than 0.25 and the player isn't in creative or spectator mode, it is logged that \"<player> moved wrongly!\", and the player is teleported back to their current (before this packet) server-side position. In addition, if the player's hitbox stationary at the requested position would intersect with a block, and they aren't in spectator mode, they are teleported back without a log message.\n\nChecking for illegal flight is achieved like this:\n\nWhen a movement packet is received, a flag indicating whether or not the player is floating mid-air is updated. The flag is set if the move test described above detected no collision below the player and the y component of the offset from the player's current position to the requested one is greater than -0.5, unless any of various conditions permitting flight (creative mode, elytra, levitation effect, etc., but not jumping) are met. Each server tick, it is checked if the flag has been set for more than 80 consecutive ticks. If so, and the player isn't currently sleeping, dead or riding a vehicle, they are kicked for multiplayer.disconnect.flying.",
      "packet_id": 28,
      "state": "Play",
      "clientbound": false,
      "fields": [
        {
          "name": "x",
          "doc": "Absolute position.",
          "protocol_type": "double"
        },
        {
          "name": "feet_y",
          "doc": "Absolute feet position, normally Head Y - 1.62.",
          "protocol_type": "double"
        },
        {
          "name": "z",
          "doc": "Absolute position.",
          "protocol_type": "double"
        },
        {
          "name": "flags",
          "doc": "Bit field: 0x01: on ground, 0x02: pushing against wall.",
          "protocol_type": "byte"
        }
      ]
    },
    {
      "name": "SetPlayerPositionandRotation",
      "resource": "move_player_pos_rot",
      "doc": "A combination of Move Player Rotation and Move Player Position.",
      "packet_id": 29,
      "state": "Play",
      "clientbound": false,
      "fields": [
        {
          "name": "x",
          "doc": "Absolute position.",
          "protocol_type": "double"
        },
        {
          "name": "feet_y",
          "doc": "Absolute feet position, normally Head Y - 1.62.",
          "protocol_type": "double"
        },
        {
          "name": "z",
          "doc": "Absolute position.",
          "protocol_type": "double"
        },
        {
          "name": "yaw",
          "doc": "Absolute rotation on the X Axis, in degrees.",
          "protocol_type": "float"
        },
        {
          "name": "pitch",
          "doc": "Absolute rotation on the Y Axis, in degrees.",
          "protocol_type": "float"
        },
        {
          "name": "flags",
          "doc": "Bit field: 0x01: on ground, 0x02: pushing against wall.",
          "protocol_type": "byte"
        }
      ]
    },
    {
      "name": "SetPlayerRotation",
      "resource": "move_player_rot",
      "doc": "The unit circle for yaw\n\nThe unit circle of yaw, redrawn\n\nUpdates the direction the player is looking in.\n\nYaw is measured in degrees, and does not follow classical trigonometry rules. The unit circle of yaw on the XZ-plane starts at (0, 1) and turns counterclockwise, with 90 at (-1, 0), 180 at (0,-1) and 270 at (1, 0). Additionally, yaw is not clamped to between 0 and 360 degrees; any number is valid, including negative numbers and numbers greater than 360.\n\nPitch is measured in degrees, where 0 is looking straight ahead, -90 is looking straight up, and 90 is looking straight down.\n\nThe yaw and pitch of player (in degrees), standing at point (x0, y0, z0) and looking towards point (x, y, z) can be calculated with:\n\ndx = x-x0dy = y-y0dz = z-z0r = sqrt(dx*dx + dy*dy + dz*dz)yaw = -atan2(dx,dz)/PI*180if yaw< 0 then yaw = 360 + yawpitch = -arcsin(dy/r)/PI*180\n\nYou can get a unit vector from a given yaw/pitch via:\n\nx = -cos(pitch)* sin(yaw)y = -sin(pitch)z = cos(pitch)* cos(yaw)",
      "packet_id": 30,
      "state": "Play",
      "clientbound": false,
      "fields": [
        {
          "name": "yaw",
          "doc": "Absolute rotation on the X Axis, in degrees.",
          "protocol_type": "float"
        },
        {
          "name": "pitch",
          "doc": "Absolute rotation on the Y Axis, in degrees.",
          "protocol_type": "float"
        },
        {
          "name": "flags",
          "doc": "Bit field: 0x01: on ground, 0x02: pushing against wall.",
          "protocol_type": "byte"
        }
      ]
    },
    {
      "name": "SetPlayerMovementFlags",
      "resource": "move_player_status_only",
      "doc": "This packet as well as Set Player Position, Set Player Rotation, and Set Player Position and Rotation are called the “serverbound movement packets”. Vanilla clients will send Move Player Position once every 20 ticks even for a stationary player.\n\nThis packet is used to indicate whether the player is on ground (walking/swimming), or airborne (jumping/falling).\n\nWhen dropping from sufficient height, fall damage is applied when this state goes from false to true. The amount of damage applied is based on the point where it last changed from true to false. Note that there are several movement related packets containing this state.",
      "packet_id": 31,
      "state": "Play",
      "clientbound": false,
      "fields": [
        {
          "name": "flags",
          "doc": "Bit field: 0x01: on ground, 0x02: pushing against wall.",
          "protocol_type": "byte"
        }
      ]
    },
    {
      "name": "MoveVehicle",
      "resource": "move_vehicle",
      "doc": "Sent when a player moves in a vehicle. Fields are the same as in Set Player Position and Rotation. Note that all fields use absolute positioning and do not allow for relative positioning.",
      "packet_id": 32,
      "state": "Play",
      "clientbound": false,
      "fields": [
        {
          "name": "x",
          "doc": "Absolute position (X coordinate).",
          "protocol_type": "double"
        },
        {
          "name": "y",
          "doc": "Absolute position (Y coordinate).",
          "protocol_type": "double"
        },
        {
          "name": "z",
          "doc": "Absolute position (Z coordinate).",
          "protocol_type": "double"
        },
        {
          "name": "yaw",
          "doc": "Absolute rotation on the vertical axis, in degrees.",
          "protocol_type": "float"
        },
        {
          "name": "pitch",
          "doc": "Absolute rotation on the horizontal axis, in degrees.",
          "protocol_type": "float"
        },
        {
          "name": "on_ground",
          "doc": "(This value does not seem to exist)",
          "protocol_type": "boolean"
        }
      ]
    },
    {
      "name": "PaddleBoat",
      "resource": "paddle_boat",
      "doc": "Used to visually update whether boat paddles are turning. The server will update the Boat entity metadata to match the values here.",
      "packet_id": 33,
      "state": "Play",
      "clientbound": false,
      "fields": [
        {
          "name": "left_paddle_turning",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "boolean"
        },
        {
          "name": "right_paddle_turning",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "boolean"
        }
      ]
    },
    {
      "name": "PickItemFromBlock",
      "resource": "pick_item_from_block",
      "doc": "Used for pick block functionality (middle click) on blocks to retrieve items from the inventory in survival or creative mode or create them in creative mode. See Controls#Pick_Block for more information.",
      "packet_id": 34,
      "state": "Play",
      "clientbound": false,
      "fields": [
        {
          "name": "location",
          "doc": "The location of the block.",
          "protocol_type": "position"
        },
        {
          "name": "include_data",
          "doc": "Used to tell the server to include block data in the new stack, works only if in creative mode.",
          "protocol_type": "boolean"
        }
      ]
    },
    {
      "name": "PickItemFromEntity",
      "resource": "pick_item_from_entity",
      "doc": "Used for pick block functionality (middle click) on entities to retrieve items from the inventory in survival or creative mode or create them in creative mode. See Controls#Pick_Block for more information.",
      "packet_id": 35,
      "state": "Play",
      "clientbound": false,
      "fields": [
        {
          "name": "entity_id",
          "doc": "The ID of the entity to pick.",
          "protocol_type": "varint"
        },
        {
          "name": "include_data",
          "doc": "Unused by the vanilla server.",
          "protocol_type": "boolean"
        }
      ]
    },
    {
      "name": "PlayPingRequest",
      "resource": "ping_request",
      "doc": "Documentation is missing for this packet.",
      "packet_id": 36,
      "state": "Play",
      "clientbound": false,
      "fields": [
        {
          "name": "payload",
          "doc": "May be any number. vanilla clients use a system-dependent time value which is counted in milliseconds.",
          "protocol_type": "long"
        }
      ]
    },
    {
      "name": "PlaceRecipe",
      "resource": "place_recipe",
      "doc": "This packet is sent when a player clicks a recipe in the crafting book that is craftable (white border).",
      "packet_id": 37,
      "state": "Play",
      "clientbound": false,
      "fields": [
        {
          "name": "window_id",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "varint"
        },
        {
          "name": "recipe_id",
          "doc": "ID of recipe previously defined in Recipe Book Add.",
          "protocol_type": "varint"
        },
        {
          "name": "make_all",
          "doc": "Affects the amount of items processed; true if shift is down when clicked.",
          "protocol_type": "boolean"
        }
      ]
    },
    {
      "name": "ServerboundPlayerAbilities",
      "resource": "player_abilities",
      "doc": "The vanilla client sends this packet when the player starts/stops flying with the Flags parameter changed accordingly.",
      "packet_id": 38,
      "state": "Play",
      "clientbound": false,
      "fields": [
        {
          "name": "flags",
          "doc": "Bit mask. 0x02: is flying.",
          "protocol_type": "byte"
        }
      ]
    },
    {
      "name": "PlayerAction",
      "resource": "player_action",
      "doc": "Sent when the player mines a block. A vanilla server only accepts digging packets with coordinates within a 6-unit radius between the center of the block and the player's eyes.",
      "packet_id": 39,
      "state": "Play",
      "clientbound": false,
      "fields": [
        {
          "name": "status",
          "doc": "The action the player is taking against the block (see below).",
          "protocol_type": "varint_enum"
        },
        {
          "name": "location",
          "doc": "Block position.",
          "protocol_type": "position"
        },
        {
          "name": "face",
          "doc": "The face being hit (see below).",
          "protocol_type": "byte_enum"
        },
        {
          "name": "sequence",
          "doc": "Block change sequence number (see#Acknowledge Block Change).",
          "protocol_type": "varint"
        }
      ]
    },
    {
      "name": "PlayerCommand",
      "resource": "player_command",
      "doc": "Sent by the client to indicate that it has performed certain actions: sneaking (crouching), sprinting, exiting a bed, jumping with a horse, and opening a horse's inventory while riding it.",
      "packet_id": 40,
      "state": "Play",
      "clientbound": false,
      "fields": [
        {
          "name": "entity_id",
          "doc": "Player ID (ignored by the vanilla server)",
          "protocol_type": "varint"
        },
        {
          "name": "action_id",
          "doc": "The ID of the action, see below.",
          "protocol_type": "varint_enum"
        },
        {
          "name": "jump_boost",
          "doc": "Only used by the “start jump with horse” action, in which case it ranges from 0 to 100. In all other cases it is 0.",
          "protocol_type": "varint"
        }
      ]
    },
    {
      "name": "PlayerInput",
      "resource": "player_input",
      "doc": "Documentation is missing for this packet.",
      "packet_id": 41,
      "state": "Play",
      "clientbound": false,
      "fields": [
        {
          "name": "flags",
          "doc": "Bit mask; see below",
          "protocol_type": "unsigned_byte"
        }
      ]
    },
    {
      "name": "PlayerLoaded",
      "resource": "player_loaded",
      "doc": "Sent by the client after the server starts sending chunks and the player's chunk has loaded.",
      "packet_id": 42,
      "state": "Play",
      "clientbound": false,
      "fields": []
    },
    {
      "name": "PlayPong",
      "resource": "pong",
      "doc": "Response to the clientbound packet (Ping) with the same id.",
      "packet_id": 43,
      "state": "Play",
      "clientbound": false,
      "fields": [
        {
          "name": "id",
          "doc": "id is the same as the ping packet",
          "protocol_type": "int"
        }
      ]
    },
    {
      "name": "ChangeRecipeBookSettings",
      "resource": "recipe_book_change_settings",
      "doc": "Replaces Recipe Book Data, type 1.",
      "packet_id": 44,
      "state": "Play",
      "clientbound": false,
      "fields": [
        {
          "name": "book_id",
          "doc": "0: crafting, 1: furnace, 2: blast furnace, 3: smoker.",
          "protocol_type": "varint_enum"
        },
        {
          "name": "book_open",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "boolean"
        },
        {
          "name": "filter_active",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "boolean"
        }
      ]
    },
    {
      "name": "SetSeenRecipe",
      "resource": "recipe_book_seen_recipe",
      "doc": "Sent when recipe is first seen in recipe book. Replaces Recipe Book Data, type 0.",
      "packet_id": 45,
      "state": "Play",
      "clientbound": false,
      "fields": [
        {
          "name": "recipe_id",
          "doc": "ID of recipe previously defined in Recipe Book Add.",
          "protocol_type": "varint"
        }
      ]
    },
    {
      "name": "RenameItem",
      "resource": "rename_item",
      "doc": "Sent as a player is renaming an item in an anvil (each keypress in the anvil UI sends a new Rename Item packet). If the new name is empty, then the item loses its custom name (this is different from setting the custom name to the normal name of the item). The item name may be no longer than 50 characters long, and if it is longer than that, then the rename is silently ignored.",
      "packet_id": 46,
      "state": "Play",
      "clientbound": false,
      "fields": [
        {
          "name": "item_name",
          "doc": "The new name of the item.",
          "protocol_type": "string"
        }
      ]
    },
    {
      "name": "PlayResourcePackResponse",
      "resource": "resource_pack",
      "doc": "Documentation is missing for this packet.",
      "packet_id": 47,
      "state": "Play",
      "clientbound": false,
      "fields": [
        {
          "name": "uuid",
          "doc": "The unique identifier of the resource pack received in the Add Resource Pack (play) request.",
          "protocol_type": "uuid"
        },
        {
          "name": "result",
          "doc": "Result ID (see below).",
          "protocol_type": "varint_enum"
        }
      ]
    },
    {
      "name": "SeenAdvancements",
      "resource": "seen_advancements",
      "doc": "Documentation is missing for this packet.",
      "packet_id": 48,
      "state": "Play",
      "clientbound": false,
      "fields": [
        {
          "name": "action",
          "doc": "0: Opened tab, 1: Closed screen.",
          "protocol_type": "varint_enum"
        },
        {
          "name": "tab_id",
          "doc": "Only present if action is Opened tab.",
          "protocol_type": "optional_identifier"
        }
      ]
    },
    {
      "name": "SelectTrade",
      "resource": "select_trade",
      "doc": "When a player selects a specific trade offered by a villager NPC.",
      "packet_id": 49,
      "state": "Play",
      "clientbound": false,
      "fields": [
        {
          "name": "selected_slot",
          "doc": "The selected slot in the players current (trading) inventory.",
          "protocol_type": "varint"
        }
      ]
    },
    {
      "name": "SetBeaconEffect",
      "resource": "set_beacon",
      "doc": "Changes the effect of the current beacon.",
      "packet_id": 50,
      "state": "Play",
      "clientbound": false,
      "fields": [
        {
          "name": "primary_effect",
          "doc": "A Potion ID.",
          "protocol_type": "prefixed_optional_varint"
        },
        {
          "name": "secondary_effect",
          "doc": "A Potion ID.",
          "protocol_type": "prefixed_optional_varint"
        }
      ]
    },
    {
      "name": "ServerboundSetHeldItem",
      "resource": "set_carried_item",
      "doc": "Sent when the player changes the slot selection.",
      "packet_id": 51,
      "state": "Play",
      "clientbound": false,
      "fields": [
        {
          "name": "slot",
          "doc": "The slot which the player has selected (0–8).",
          "protocol_type": "short"
        }
      ]
    },
    {
      "name": "ProgramCommandBlock",
      "resource": "set_command_block",
      "doc": "Documentation is missing for this packet.",
      "packet_id": 52,
      "state": "Play",
      "clientbound": false,
      "fields": [
        {
          "name": "location",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "position"
        },
        {
          "name": "command",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "string"
        },
        {
          "name": "mode",
          "doc": "0: chain, 1: repeating, 2: impulse.",
          "protocol_type": "varint_enum"
        },
        {
          "name": "flags",
          "doc": "0x01: Track Output (if false, the output of the previous command will not be stored within the command block); 0x02: Is conditional; 0x04: Automatic.",
          "protocol_type": "byte"
        }
      ]
    },
    {
      "name": "ProgramCommandBlockMinecart",
      "resource": "set_command_minecart",
      "doc": "Documentation is missing for this packet.",
      "packet_id": 53,
      "state": "Play",
      "clientbound": false,
      "fields": [
        {
          "name": "entity_id",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "varint"
        },
        {
          "name": "command",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "string"
        },
        {
          "name": "track_output",
          "doc": "If false, the output of the previous command will not be stored within the command block.",
          "protocol_type": "boolean"
        }
      ]
    },
    {
      "name": "SetCreativeModeSlot",
      "resource": "set_creative_mode_slot",
      "doc": "While the user is in the standard inventory (i.e., not a crafting bench) in Creative mode, the player will send this packet.\n\nClicking in the creative inventory menu is quite different from non-creative inventory management. Picking up an item with the mouse actually deletes the item from the server, and placing an item into a slot or dropping it out of the inventory actually tells the server to create the item from scratch. (This can be verified by clicking an item that you don't mind deleting, then severing the connection to the server; the item will be nowhere to be found when you log back in.) As a result of this implementation strategy, the \"Destroy Item\" slot is just a client-side implementation detail that means \"I don't intend to recreate this item.\". Additionally, the long listings of items (by category, etc.) are a client-side interface for choosing which item to create. Picking up an item from such listings sends no packets to the server; only when you put it somewhere does it tell the server to create the item in that location.\n\nThis action can be described as \"set inventory slot\". Picking up an item sets the slot to item ID -1. Placing an item into an inventory slot sets the slot to the specified item. Dropping an item (by clicking outside the window) effectively sets slot -1 to the specified item, which causes the server to spawn the item entity, etc.. All other inventory slots are numbered the same as the non-creative inventory (including slots for the 2x2 crafting menu, even though they aren't visible in the vanilla client).",
      "packet_id": 54,
      "state": "Play",
      "clientbound": false,
      "fields": [
        {
          "name": "slot",
          "doc": "Inventory slot.",
          "protocol_type": "short"
        },
        {
          "name": "clicked_item",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "slot"
        }
      ]
    },
    {
      "name": "ProgramJigsawBlock",
      "resource": "set_jigsaw_block",
      "doc": "Sent when Done is pressed on the Jigsaw Block interface.",
      "packet_id": 55,
      "state": "Play",
      "clientbound": false,
      "fields": [
        {
          "name": "location",
          "doc": "Block entity location",
          "protocol_type": "position"
        },
        {
          "name": "name",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "identifier"
        },
        {
          "name": "target",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "identifier"
        },
        {
          "name": "pool",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "identifier"
        },
        {
          "name": "final_state",
          "doc": "\"Turns into\" on the GUI, final_state in NBT.",
          "protocol_type": "string"
        },
        {
          "name": "joint_type",
          "doc": "rollable if the attached piece can be rotated, else aligned.",
          "protocol_type": "string"
        },
        {
          "name": "selection_priority",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "varint"
        },
        {
          "name": "placement_priority",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "varint"
        }
      ]
    },
    {
      "name": "ProgramStructureBlock",
      "resource": "set_structure_block",
      "doc": "Documentation is missing for this packet.",
      "packet_id": 56,
      "state": "Play",
      "clientbound": false,
      "fields": [
        {
          "name": "location",
          "doc": "Block entity location.",
          "protocol_type": "position"
        },
        {
          "name": "action",
          "doc": "An additional action to perform beyond simply saving the given data; see below.",
          "protocol_type": "varint_enum"
        },
        {
          "name": "mode",
          "doc": "One of SAVE (0), LOAD (1), CORNER (2), DATA (3).",
          "protocol_type": "varint_enum"
        },
        {
          "name": "name",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "string"
        },
        {
          "name": "offset_x",
          "doc": "Between -48 and 48.",
          "protocol_type": "byte"
        },
        {
          "name": "offset_y",
          "doc": "Between -48 and 48.",
          "protocol_type": "byte"
        },
        {
          "name": "offset_z",
          "doc": "Between -48 and 48.",
          "protocol_type": "byte"
        },
        {
          "name": "size_x",
          "doc": "Between 0 and 48.",
          "protocol_type": "byte"
        },
        {
          "name": "size_y",
          "doc": "Between 0 and 48.",
          "protocol_type": "byte"
        },
        {
          "name": "size_z",
          "doc": "Between 0 and 48.",
          "protocol_type": "byte"
        },
        {
          "name": "mirror",
          "doc": "One of NONE (0), LEFT_RIGHT (1), FRONT_BACK (2).",
          "protocol_type": "varint_enum"
        },
        {
          "name": "rotation",
          "doc": "One of NONE (0), CLOCKWISE_90 (1), CLOCKWISE_180 (2), COUNTERCLOCKWISE_90 (3).",
          "protocol_type": "varint_enum"
        },
        {
          "name": "metadata",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "string"
        },
        {
          "name": "integrity",
          "doc": "Between 0 and 1.",
          "protocol_type": "float"
        },
        {
          "name": "seed",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "varlong"
        },
        {
          "name": "flags",
          "doc": "0x01: Ignore entities; 0x02: Show air; 0x04: Show bounding box.",
          "protocol_type": "byte"
        }
      ]
    },
    {
      "name": "UpdateSign",
      "resource": "sign_update",
      "doc": "This message is sent from the client to the server when the “Done” button is pushed after placing a sign.\n\nThe server only accepts this packet after Open Sign Editor, otherwise this packet is silently ignored.",
      "packet_id": 57,
      "state": "Play",
      "clientbound": false,
      "fields": [
        {
          "name": "location",
          "doc": "Block Coordinates.",
          "protocol_type": "position"
        },
        {
          "name": "is_front_text",
          "doc": "Whether the updated text is in front or on the back of the sign",
          "protocol_type": "boolean"
        },
        {
          "name": "line_1",
          "doc": "First line of text in the sign.",
          "protocol_type": "string"
        },
        {
          "name": "line_2",
          "doc": "Second line of text in the sign.",
          "protocol_type": "string"
        },
        {
          "name": "line_3",
          "doc": "Third line of text in the sign.",
          "protocol_type": "string"
        },
        {
          "name": "line_4",
          "doc": "Fourth line of text in the sign.",
          "protocol_type": "string"
        }
      ]
    },
    {
      "name": "SwingArm",
      "resource": "swing",
      "doc": "Sent when the player's arm swings.",
      "packet_id": 58,
      "state": "Play",
      "clientbound": false,
      "fields": [
        {
          "name": "hand",
          "doc": "Hand used for the animation. 0: main hand, 1: off hand.",
          "protocol_type": "varint_enum"
        }
      ]
    },
    {
      "name": "TeleportToEntity",
      "resource": "teleport_to_entity",
      "doc": "Teleports the player to the given entity. The player must be in spectator mode.\n\nThe vanilla client only uses this to teleport to players, but it appears to accept any type of entity. The entity does not need to be in the same dimension as the player; if necessary, the player will be respawned in the right world. If the given entity cannot be found (or isn't loaded), this packet will be ignored.",
      "packet_id": 59,
      "state": "Play",
      "clientbound": false,
      "fields": [
        {
          "name": "target_player",
          "doc": "UUID of the player to teleport to (can also be an entity UUID).",
          "protocol_type": "uuid"
        }
      ]
    },
    {
      "name": "UseItemOn",
      "resource": "use_item_on",
      "doc": "Documentation is missing for this packet.",
      "packet_id": 60,
      "state": "Play",
      "clientbound": false,
      "fields": [
        {
          "name": "hand",
          "doc": "The hand from which the block is placed; 0: main hand, 1: off hand.",
          "protocol_type": "varint_enum"
        },
        {
          "name": "location",
          "doc": "Block position.",
          "protocol_type": "position"
        },
        {
          "name": "face",
          "doc": "The face on which the block is placed (as documented at Player Action).",
          "protocol_type": "varint_enum"
        },
        {
          "name": "cursor_position_x",
          "doc": "The position of the crosshair on the block, from 0 to 1 increasing from west to east.",
          "protocol_type": "float"
        },
        {
          "name": "cursor_position_y",
          "doc": "The position of the crosshair on the block, from 0 to 1 increasing from bottom to top.",
          "protocol_type": "float"
        },
        {
          "name": "cursor_position_z",
          "doc": "The position of the crosshair on the block, from 0 to 1 increasing from north to south.",
          "protocol_type": "float"
        },
        {
          "name": "inside_block",
          "doc": "True when the player's head is inside of a block.",
          "protocol_type": "boolean"
        },
        {
          "name": "world_border_hit",
          "doc": "Seems to always be false, even when interacting with blocks around or outside the world border, or while the player is outside the border.",
          "protocol_type": "boolean"
        },
        {
          "name": "sequence",
          "doc": "Block change sequence number (see#Acknowledge Block Change).",
          "protocol_type": "varint"
        }
      ]
    },
    {
      "name": "UseItem",
      "resource": "use_item",
      "doc": "Sent when pressing the Use Item key (default: right click) with an item in hand.",
      "packet_id": 61,
      "state": "Play",
      "clientbound": false,
      "fields": [
        {
          "name": "hand",
          "doc": "Hand used for the animation. 0: main hand, 1: off hand.",
          "protocol_type": "varint_enum"
        },
        {
          "name": "sequence",
          "doc": "Block change sequence number (see#Acknowledge Block Change).",
          "protocol_type": "varint"
        },
        {
          "name": "yaw",
          "doc": "Player head rotation along the Y-Axis.",
          "protocol_type": "float"
        },
        {
          "name": "pitch",
          "doc": "Player head rotation along the X-Axis.",
          "protocol_type": "float"
        }
      ]
    },
    {
      "name": "BundleDelimiter",
      "resource": "bundle_delimiter",
      "doc": "The delimiter for a bundle of packets. When received, the client should store every subsequent packet it receives, and wait until another delimiter is received. Once that happens, the client is guaranteed to process every packet in the bundle on the same tick, and the client should stop storing packets.\n\nAs of 1.20.6, the vanilla server only uses this to ensure Spawn Entity and associated packets used to configure the entity happen on the same tick. Each entity gets a separate bundle.\n\nThe vanilla client doesn't allow more than 4096 packets in the same bundle.",
      "packet_id": 0,
      "state": "Play",
      "clientbound": true,
      "fields": []
    },
    {
      "name": "SpawnEntity",
      "resource": "add_entity",
      "doc": "Sent by the server when an entity (aside from Experience Orb) is created.",
      "packet_id": 1,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "entity_id",
          "doc": "A unique integer ID mostly used in the protocol to identify the entity.",
          "protocol_type": "varint"
        },
        {
          "name": "entity_uuid",
          "doc": "A unique identifier that is mostly used in persistence and places where the uniqueness matters more.",
          "protocol_type": "uuid"
        },
        {
          "name": "type",
          "doc": "ID in the minecraft:entity_type registry (see \"type\" field in Entity metadata#Entities).",
          "protocol_type": "varint"
        },
        {
          "name": "x",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "double"
        },
        {
          "name": "y",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "double"
        },
        {
          "name": "z",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "double"
        },
        {
          "name": "pitch",
          "doc": "To get the real pitch, you must divide this by (256.0F/ 360.0F)",
          "protocol_type": "angle"
        },
        {
          "name": "yaw",
          "doc": "To get the real yaw, you must divide this by (256.0F/ 360.0F)",
          "protocol_type": "angle"
        },
        {
          "name": "head_yaw",
          "doc": "Only used by living entities, where the head of the entity may differ from the general body rotation.",
          "protocol_type": "angle"
        },
        {
          "name": "data",
          "doc": "Meaning dependent on the value of the Type field, see Object Data for details.",
          "protocol_type": "varint"
        },
        {
          "name": "velocity_x",
          "doc": "Same units as Set Entity Velocity.",
          "protocol_type": "short"
        }
      ]
    },
    {
      "name": "SpawnExperienceOrb",
      "resource": "add_experience_orb",
      "doc": "Spawns one or more experience orbs.",
      "packet_id": 2,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "entity_id",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "varint"
        },
        {
          "name": "x",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "double"
        },
        {
          "name": "y",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "double"
        },
        {
          "name": "z",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "double"
        },
        {
          "name": "count",
          "doc": "The amount of experience this orb will reward once collected.",
          "protocol_type": "short"
        }
      ]
    },
    {
      "name": "EntityAnimation",
      "resource": "animate",
      "doc": "Sent whenever an entity should change animation.",
      "packet_id": 3,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "entity_id",
          "doc": "Player ID.",
          "protocol_type": "varint"
        },
        {
          "name": "animation",
          "doc": "Animation ID (see below).",
          "protocol_type": "unsigned_byte"
        }
      ]
    },
    {
      "name": "AwardStatistics",
      "resource": "award_stats",
      "doc": "Sent as a response to Client Status (id 1). Will only send the changed values if previously requested.",
      "packet_id": 4,
      "state": "Play",
      "clientbound": true,
      "fields": []
    },
    {
      "name": "AcknowledgeBlockChange",
      "resource": "block_changed_ack",
      "doc": "Acknowledges a user-initiated block change. After receiving this packet, the client will display the block state sent by the server instead of the one predicted by the client.",
      "packet_id": 5,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "sequence_id",
          "doc": "Represents the sequence to acknowledge, this is used for properly syncing block changes to the client after interactions.",
          "protocol_type": "varint"
        }
      ]
    },
    {
      "name": "SetBlockDestroyStage",
      "resource": "block_destruction",
      "doc": "0–9 are the displayable destroy stages and each other number means that there is no animation on this coordinate.\n\nBlock break animations can still be applied on air; the animation will remain visible although there is no block being broken. However, if this is applied to a transparent block, odd graphical effects may happen, including water losing its transparency. (An effect similar to this can be seen in normal gameplay when breaking ice blocks)\n\nIf you need to display several break animations at the same time you have to give each of them a unique Entity ID. The entity ID does not need to correspond to an actual entity on the client. It is valid to use a randomly generated number.",
      "packet_id": 6,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "entity_id",
          "doc": "The ID of the entity breaking the block.",
          "protocol_type": "varint"
        },
        {
          "name": "location",
          "doc": "Block Position.",
          "protocol_type": "position"
        },
        {
          "name": "destroy_stage",
          "doc": "0–9 to set it, any other value to remove it.",
          "protocol_type": "unsigned_byte"
        }
      ]
    },
    {
      "name": "BlockEntityData",
      "resource": "block_entity_data",
      "doc": "Sets the block entity associated with the block at the given location.",
      "packet_id": 7,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "location",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "position"
        },
        {
          "name": "type",
          "doc": "The type of the block entity",
          "protocol_type": "varint"
        },
        {
          "name": "nbt_data",
          "doc": "Data to set. May be a TAG_END (0), in which case the block entity at the given location is removed (though this is not required since the client will remove the block entity automatically on chunk unload or block removal).",
          "protocol_type": "nbt"
        }
      ]
    },
    {
      "name": "BlockAction",
      "resource": "block_event",
      "doc": "This packet is used for a number of actions and animations performed by blocks, usually non-persistent. The client ignores the provided block type and instead uses the block state in their world.\n\nSee Block Actions for a list of values.\n\nThis packet uses a block ID from the minecraft:block registry, not a block state.",
      "packet_id": 8,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "location",
          "doc": "Block coordinates.",
          "protocol_type": "position"
        },
        {
          "name": "action_id_byte_1",
          "doc": "Varies depending on block — see Block Actions.",
          "protocol_type": "unsigned_byte"
        },
        {
          "name": "action_parameter_byte_2",
          "doc": "Varies depending on block — see Block Actions.",
          "protocol_type": "unsigned_byte"
        },
        {
          "name": "block_type",
          "doc": "The block type ID for the block. This value is unused by the vanilla client, as it will infer the type of block based on the given position.",
          "protocol_type": "varint"
        }
      ]
    },
    {
      "name": "BlockUpdate",
      "resource": "block_update",
      "doc": "Fired whenever a block is changed within the render distance.\n\nChanging a block in a chunk that is not loaded is not a stable action. The vanilla client currently uses a shared empty chunk which is modified for all block changes in unloaded chunks; while in 1.9 this chunk never renders in older versions the changed block will appear in all copies of the empty chunk. Servers should avoid sending block changes in unloaded chunks and clients should ignore such packets.",
      "packet_id": 9,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "location",
          "doc": "Block Coordinates.",
          "protocol_type": "position"
        },
        {
          "name": "block_id",
          "doc": "The new block state ID for the block as given in the block state registry.",
          "protocol_type": "varint"
        }
      ]
    },
    {
      "name": "BossBar",
      "resource": "boss_event",
      "doc": "Documentation is missing for this packet.",
      "packet_id": 10,
      "state": "Play",
      "clientbound": true,
      "fields": []
    },
    {
      "name": "ChangeDifficulty",
      "resource": "change_difficulty",
      "doc": "Changes the difficulty setting in the client's option menu",
      "packet_id": 11,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "difficulty",
          "doc": "0: peaceful, 1: easy, 2: normal, 3: hard.",
          "protocol_type": "unsigned_byte_enum"
        },
        {
          "name": "difficulty_locked",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "boolean"
        }
      ]
    },
    {
      "name": "ChunkBatchFinished",
      "resource": "chunk_batch_finished",
      "doc": "Marks the end of a chunk batch. The vanilla client marks the time it receives this packet and calculates the elapsed duration since the beginning of the chunk batch. The server uses this duration and the batch size received in this packet to estimate the number of milliseconds elapsed per chunk received. This value is then used to calculate the desired number of chunks per tick through the formula 25/ millisPerChunk, which is reported to the server through Chunk Batch Received. This likely uses 25 instead of the normal tick duration of 50 so chunk processing will only use half of the client's and network's bandwidth.\n\nThe vanilla client uses the samples from the latest 15 batches to estimate the milliseconds per chunk number.",
      "packet_id": 12,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "batch_size",
          "doc": "Number of chunks.",
          "protocol_type": "varint"
        }
      ]
    },
    {
      "name": "ChunkBatchStart",
      "resource": "chunk_batch_start",
      "doc": "Marks the start of a chunk batch. The vanilla client marks and stores the time it receives this packet.",
      "packet_id": 13,
      "state": "Play",
      "clientbound": true,
      "fields": []
    },
    {
      "name": "ChunkBiomes",
      "resource": "chunks_biomes",
      "doc": "Documentation is missing for this packet.",
      "packet_id": 14,
      "state": "Play",
      "clientbound": true,
      "fields": []
    },
    {
      "name": "ClearTitles",
      "resource": "clear_titles",
      "doc": "Clear the client's current title information, with the option to also reset it.",
      "packet_id": 15,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "reset",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "boolean"
        }
      ]
    },
    {
      "name": "CommandSuggestionsResponse",
      "resource": "command_suggestions",
      "doc": "The server responds with a list of auto-completions of the last word sent to it. In the case of regular chat, this is a player username. Command names and parameters are also supported. The client sorts these alphabetically before listing them.",
      "packet_id": 16,
      "state": "Play",
      "clientbound": true,
      "fields": []
    },
    {
      "name": "Commands",
      "resource": "commands",
      "doc": "Lists all of the commands on the server, and how they are parsed.\n\nThis is a directed graph, with one root node. Each redirect or child node must refer only to nodes that have already been declared.",
      "packet_id": 17,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "nodes",
          "doc": "An array of nodes.",
          "protocol_type": "prefixed_array_of_node"
        },
        {
          "name": "root_index",
          "doc": "Index of the root node in the previous array.",
          "protocol_type": "varint"
        }
      ]
    },
    {
      "name": "CloseContainer",
      "resource": "container_close",
      "doc": "This packet is sent from the server to the client when a window is forcibly closed, such as when a chest is destroyed while it's open. The vanilla client disregards the provided window ID and closes any active window.",
      "packet_id": 18,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "window_id",
          "doc": "This is the ID of the window that was closed. 0 for inventory.",
          "protocol_type": "varint"
        }
      ]
    },
    {
      "name": "SetContainerContent",
      "resource": "container_set_content",
      "doc": "The inventory slots\n\nReplaces the contents of a container window. Sent by the server upon initialization of a container window or the player's inventory, and in response to state ID mismatches (see#Click Container).",
      "packet_id": 19,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "window_id",
          "doc": "The ID of window which items are being sent for. 0 for player inventory. The client ignores any packets targeting a Window ID other than the current one. However, an exception is made for the player inventory, which may be targeted at any time. (The vanilla server does not appear to utilize this special case.)",
          "protocol_type": "varint"
        },
        {
          "name": "state_id",
          "doc": "A server-managed sequence number used to avoid desynchronization; see#Click Container.",
          "protocol_type": "varint"
        },
        {
          "name": "slot_data",
          "doc": "Item being dragged with the mouse.",
          "protocol_type": "prefixed_array_of_slot"
        },
        {
          "name": "carried_item",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "slot"
        }
      ]
    },
    {
      "name": "SetContainerProperty",
      "resource": "container_set_data",
      "doc": "This packet is used to inform the client that part of a GUI window should be updated.",
      "packet_id": 20,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "window_id",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "varint"
        },
        {
          "name": "property",
          "doc": "The property to be updated, see below.",
          "protocol_type": "short"
        },
        {
          "name": "value",
          "doc": "The new value for the property, see below.",
          "protocol_type": "short"
        }
      ]
    },
    {
      "name": "SetContainerSlot",
      "resource": "container_set_slot",
      "doc": "Sent by the server when an item in a slot (in a window) is added/removed.",
      "packet_id": 21,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "window_id",
          "doc": "The window which is being updated. 0 for player inventory. The client ignores any packets targeting a Window ID other than the current one; see below for exceptions.",
          "protocol_type": "varint"
        },
        {
          "name": "state_id",
          "doc": "A server-managed sequence number used to avoid desynchronization; see#Click Container.",
          "protocol_type": "varint"
        },
        {
          "name": "slot",
          "doc": "The slot that should be updated.",
          "protocol_type": "short"
        },
        {
          "name": "slot_data",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "slot"
        }
      ]
    },
    {
      "name": "PlayCookieRequest",
      "resource": "cookie_request",
      "doc": "Requests a cookie that was previously stored.",
      "packet_id": 22,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "key",
          "doc": "The identifier of the cookie.",
          "protocol_type": "identifier"
        }
      ]
    },
    {
      "name": "SetCooldown",
      "resource": "cooldown",
      "doc": "Applies a cooldown period to all items with the given type. Used by the vanilla server with enderpearls. This packet should be sent when the cooldown starts and also when the cooldown ends (to compensate for lag), although the client will end the cooldown automatically. Can be applied to any item, note that interactions still get sent to the server with the item but the client does not play the animation nor attempt to predict results (i.e block placing).",
      "packet_id": 23,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "item_id",
          "doc": "Numeric ID of the item to apply a cooldown to.",
          "protocol_type": "varint"
        },
        {
          "name": "cooldown_ticks",
          "doc": "Number of ticks to apply a cooldown for, or 0 to clear the cooldown.",
          "protocol_type": "varint"
        }
      ]
    },
    {
      "name": "ChatSuggestions",
      "resource": "custom_chat_completions",
      "doc": "Unused by the vanilla server. Likely provided for custom servers to send chat message completions to clients.",
      "packet_id": 24,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "action",
          "doc": "0: Add, 1: Remove, 2: Set",
          "protocol_type": "varint_enum"
        },
        {
          "name": "entries",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "prefixed_array_of_string"
        }
      ]
    },
    {
      "name": "PlayClientboundPluginMessage",
      "resource": "custom_payload",
      "doc": "Main page: Minecraft Wiki:Projects/wiki.vg merge/Plugin channels\n\nMods and plugins can use this to send their data. Minecraft itself uses several plugin channels. These internal channels are in the minecraft namespace.\n\nMore information on how it works on Dinnerbone's blog. More documentation about internal and popular registered channels are here.",
      "packet_id": 25,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "channel",
          "doc": "Name of the plugin channel used to send the data.",
          "protocol_type": "identifier"
        },
        {
          "name": "data",
          "doc": "Any data. The length of this array must be inferred from the packet length.",
          "protocol_type": "remaining_byte_array"
        }
      ]
    },
    {
      "name": "DamageEvent",
      "resource": "damage_event",
      "doc": "Documentation is missing for this packet.",
      "packet_id": 26,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "entity_id",
          "doc": "The ID of the entity taking damage",
          "protocol_type": "varint"
        },
        {
          "name": "source_type_id",
          "doc": "The type of damage in the minecraft:damage_type registry, defined by the Registry Data packet.",
          "protocol_type": "varint"
        },
        {
          "name": "source_cause_id",
          "doc": "The ID + 1 of the entity responsible for the damage, if present. If not present, the value is 0",
          "protocol_type": "varint"
        },
        {
          "name": "source_direct_id",
          "doc": "The ID + 1 of the entity that directly dealt the damage, if present. If not present, the value is 0. If this field is present: and damage was dealt indirectly, such as by the use of a projectile, this field will contain the ID of such projectile; and damage was dealt dirctly, such as by manually attacking, this field will contain the same value as Source Cause ID.",
          "protocol_type": "varint"
        },
        {
          "name": "has_source_position",
          "doc": "Indicates the presence of the three following fields. The vanilla server sends the Source Position when the damage was dealt by the/damage command and a position was specified",
          "protocol_type": "boolean"
        },
        {
          "name": "source_position_x",
          "doc": "Only present if Has Source Position is true",
          "protocol_type": "optional_double"
        },
        {
          "name": "source_position_y",
          "doc": "Only present if Has Source Position is true",
          "protocol_type": "optional_double"
        },
        {
          "name": "source_position_z",
          "doc": "Only present if Has Source Position is true",
          "protocol_type": "optional_double"
        }
      ]
    },
    {
      "name": "DebugSample",
      "resource": "debug_sample",
      "doc": "Sample data that is sent periodically after the client has subscribed with Debug Sample Subscription.\n\nThe vanilla server only sends debug samples to players that are server operators.",
      "packet_id": 27,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "sample",
          "doc": "Array of type-dependent samples.",
          "protocol_type": "prefixed_array_of_long"
        },
        {
          "name": "sample_type",
          "doc": "See below.",
          "protocol_type": "varint_enum"
        }
      ]
    },
    {
      "name": "DeleteMessage",
      "resource": "delete_chat",
      "doc": "Removes a message from the client's chat. This only works for messages with signatures, system messages cannot be deleted with this packet.",
      "packet_id": 28,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "message_id",
          "doc": "The message Id + 1, used for validating message signature. The next field is present only when value of this field is equal to 0.",
          "protocol_type": "varint"
        },
        {
          "name": "signature",
          "doc": "The previous message's signature. Always 256 bytes and not length-prefixed.",
          "protocol_type": "optional_byte_array"
        }
      ]
    },
    {
      "name": "PlayDisconnect",
      "resource": "disconnect",
      "doc": "Sent by the server before it disconnects a client. The client assumes that the server has already closed the connection by the time the packet arrives.",
      "packet_id": 29,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "reason",
          "doc": "Displayed to the client when the connection terminates.",
          "protocol_type": "text_component"
        }
      ]
    },
    {
      "name": "DisguisedChatMessage",
      "resource": "disguised_chat",
      "doc": "Main article: Chat\n\nSends the client a chat message, but without any message signing information.\n\nThe vanilla server uses this packet when the console is communicating with players through commands, such as/say,/tell,/me, among others.",
      "packet_id": 30,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "message",
          "doc": "This is used as the content parameter when formatting the message on the client.",
          "protocol_type": "text_component"
        },
        {
          "name": "chat_type",
          "doc": "The type of chat in the minecraft:chat_type registry, defined by the Registry Data packet.",
          "protocol_type": "varint"
        },
        {
          "name": "sender_name",
          "doc": "The name of the one sending the message, usually the sender's display name. This is used as the sender parameter when formatting the message on the client.",
          "protocol_type": "text_component"
        },
        {
          "name": "target_name",
          "doc": "The name of the one receiving the message, usually the receiver's display name. This is used as the target parameter when formatting the message on the client.",
          "protocol_type": "prefixed_optional_text_component"
        }
      ]
    },
    {
      "name": "EntityEvent",
      "resource": "entity_event",
      "doc": "Entity statuses generally trigger an animation for an entity. The available statuses vary by the entity's type (and are available to subclasses of that type as well).",
      "packet_id": 31,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "entity_id",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "int"
        },
        {
          "name": "entity_status",
          "doc": "See Entity statuses for a list of which statuses are valid for each type of entity.",
          "protocol_type": "byte_enum"
        }
      ]
    },
    {
      "name": "TeleportEntity",
      "resource": "entity_position_sync",
      "doc": "The Mojang-specified name of this packet was changed in 1.21.2 from teleport_entity to entity_position_sync. There is a new teleport_entity, which this document more appropriately calls Synchronize Vehicle Position. That packet has a different function and will lead to confusing results if used in place of this one.\n\nThis packet is sent by the server when an entity moves more than 8 blocks.",
      "packet_id": 32,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "entity_id",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "varint"
        },
        {
          "name": "x",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "double"
        },
        {
          "name": "y",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "double"
        },
        {
          "name": "z",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "double"
        },
        {
          "name": "velocity_x",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "double"
        },
        {
          "name": "velocity_y",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "double"
        },
        {
          "name": "velocity_z",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "double"
        },
        {
          "name": "yaw",
          "doc": "Rotation on the X axis, in degrees.",
          "protocol_type": "float"
        },
        {
          "name": "pitch",
          "doc": "Rotation on the Y axis, in degrees.",
          "protocol_type": "float"
        },
        {
          "name": "on_ground",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "boolean"
        }
      ]
    },
    {
      "name": "Explosion",
      "resource": "explode",
      "doc": "Sent when an explosion occurs (creepers, TNT, and ghast fireballs).",
      "packet_id": 33,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "x",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "double"
        },
        {
          "name": "y",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "double"
        },
        {
          "name": "z",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "double"
        },
        {
          "name": "has_player_velocity",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "boolean"
        },
        {
          "name": "player_velocity_x",
          "doc": "X velocity of the player being pushed by the explosion. Only present if Has Player Velocity is true.",
          "protocol_type": "optional_double"
        },
        {
          "name": "player_velocity_y",
          "doc": "Y velocity of the player being pushed by the explosion. Only present if Has Player Velocity is true.",
          "protocol_type": "optional_float"
        },
        {
          "name": "player_velocity_z",
          "doc": "Z velocity of the player being pushed by the explosion. Only present if Has Player Velocity is true.",
          "protocol_type": "optional_float"
        },
        {
          "name": "explosion_particle_id",
          "doc": "The particle ID listed in Particles.",
          "protocol_type": "varint"
        },
        {
          "name": "explosion_particle_data",
          "doc": "Particle data as specified in Particles.",
          "protocol_type": "varies"
        },
        {
          "name": "explosion_sound",
          "doc": "ID in the minecraft:sound_event registry, or an inline definition.",
          "protocol_type": "id_or_sound_event"
        }
      ]
    },
    {
      "name": "UnloadChunk",
      "resource": "forget_level_chunk",
      "doc": "Tells the client to unload a chunk column.",
      "packet_id": 34,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "chunk_z",
          "doc": "Block coordinate divided by 16, rounded down.",
          "protocol_type": "int"
        },
        {
          "name": "chunk_x",
          "doc": "Block coordinate divided by 16, rounded down.",
          "protocol_type": "int"
        }
      ]
    },
    {
      "name": "GameEvent",
      "resource": "game_event",
      "doc": "Used for a wide variety of game events, from weather to bed use to game mode to demo messages.",
      "packet_id": 35,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "event",
          "doc": "See below.",
          "protocol_type": "unsigned_byte"
        },
        {
          "name": "value",
          "doc": "Depends on Event.",
          "protocol_type": "float"
        }
      ]
    },
    {
      "name": "OpenHorseScreen",
      "resource": "horse_screen_open",
      "doc": "This packet is used exclusively for opening the horse GUI. Open Screen is used for all other GUIs. The client will not open the inventory if the Entity ID does not point to an horse-like animal.",
      "packet_id": 36,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "window_id",
          "doc": "Same as the field of Open Screen.",
          "protocol_type": "varint"
        },
        {
          "name": "inventory_columns_count",
          "doc": "How many columns of horse inventory slots exist in the GUI, 3 slots per column.",
          "protocol_type": "varint"
        },
        {
          "name": "entity_id",
          "doc": "The \"owner\" entity of the GUI. The client should close the GUI if the owner entity dies or is cleared.",
          "protocol_type": "int"
        }
      ]
    },
    {
      "name": "HurtAnimation",
      "resource": "hurt_animation",
      "doc": "Plays a bobbing animation for the entity receiving damage.",
      "packet_id": 37,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "entity_id",
          "doc": "The ID of the entity taking damage",
          "protocol_type": "varint"
        },
        {
          "name": "yaw",
          "doc": "The direction the damage is coming from in relation to the entity",
          "protocol_type": "float"
        }
      ]
    },
    {
      "name": "InitializeWorldBorder",
      "resource": "initialize_border",
      "doc": "Documentation is missing for this packet.",
      "packet_id": 38,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "x",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "double"
        },
        {
          "name": "z",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "double"
        },
        {
          "name": "old_diameter",
          "doc": "Current length of a single side of the world border, in meters.",
          "protocol_type": "double"
        },
        {
          "name": "new_diameter",
          "doc": "Target length of a single side of the world border, in meters.",
          "protocol_type": "double"
        },
        {
          "name": "speed",
          "doc": "Number of real-time milli seconds until New Diameter is reached. It appears that vanilla server does not sync world border speed to game ticks, so it gets out of sync with server lag. If the world border is not moving, this is set to 0.",
          "protocol_type": "varlong"
        },
        {
          "name": "portal_teleport_boundary",
          "doc": "Resulting coordinates from a portal teleport are limited to ±value. Usually 29999984.",
          "protocol_type": "varint"
        },
        {
          "name": "warning_blocks",
          "doc": "In meters.",
          "protocol_type": "varint"
        },
        {
          "name": "warning_time",
          "doc": "In seconds as set by/worldborder warning time.",
          "protocol_type": "varint"
        }
      ]
    },
    {
      "name": "PlayClientboundKeepAlive",
      "resource": "keep_alive",
      "doc": "The server will frequently send out a keep-alive, each containing a random ID. The client must respond with the same payload (see Serverbound Keep Alive). If the client does not respond to a Keep Alive packet within 15 seconds after it was sent, the server kicks the client. Vice versa, if the server does not send any keep-alives for 20 seconds, the client will disconnect and yields a \"Timed out\" exception.\n\nThe vanilla server uses a system-dependent time in milliseconds to generate the keep alive ID value.",
      "packet_id": 39,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "keep_alive_id",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "long"
        }
      ]
    },
    {
      "name": "ChunkDataandUpdateLight",
      "resource": "level_chunk_with_light",
      "doc": "Main page: Minecraft Wiki:Projects/wiki.vg merge/Chunk Format\n\nSee also: § Unload Chunk\n\nSent when a chunk comes into the client's view distance, specifying its terrain, lighting and block entities.\n\nThe chunk must be within the view area previously specified with Set Center Chunk; see that packet for details.\n\nIt is not strictly necessary to send all block entities in this packet; it is still legal to send them with Block Entity Data later.",
      "packet_id": 40,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "chunk_x",
          "doc": "Chunk coordinate (block coordinate divided by 16, rounded down)",
          "protocol_type": "int"
        },
        {
          "name": "chunk_z",
          "doc": "Chunk coordinate (block coordinate divided by 16, rounded down)",
          "protocol_type": "int"
        },
        {
          "name": "data",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "chunk_data"
        },
        {
          "name": "light",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "light_data"
        }
      ]
    },
    {
      "name": "WorldEvent",
      "resource": "level_event",
      "doc": "Sent when a client is to play a sound or particle effect.\n\nBy default, the Minecraft client adjusts the volume of sound effects based on distance. The final boolean field is used to disable this, and instead the effect is played from 2 blocks away in the correct direction. Currently this is only used for effect 1023 (wither spawn), effect 1028 (enderdragon death), and effect 1038 (end portal opening); it is ignored on other effects.",
      "packet_id": 41,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "event",
          "doc": "The event, see below.",
          "protocol_type": "int"
        },
        {
          "name": "location",
          "doc": "The location of the event.",
          "protocol_type": "position"
        },
        {
          "name": "data",
          "doc": "Extra data for certain events, see below.",
          "protocol_type": "int"
        },
        {
          "name": "disable_relative_volume",
          "doc": "See above.",
          "protocol_type": "boolean"
        }
      ]
    },
    {
      "name": "Particle",
      "resource": "level_particles",
      "doc": "Displays the named particle",
      "packet_id": 42,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "long_distance",
          "doc": "If true, particle distance increases from 256 to 65536.",
          "protocol_type": "boolean"
        },
        {
          "name": "always_visible",
          "doc": "Whether this particle should always be visible.",
          "protocol_type": "boolean"
        },
        {
          "name": "x",
          "doc": "X position of the particle.",
          "protocol_type": "double"
        },
        {
          "name": "y",
          "doc": "Y position of the particle.",
          "protocol_type": "double"
        },
        {
          "name": "z",
          "doc": "Z position of the particle.",
          "protocol_type": "double"
        },
        {
          "name": "offset_x",
          "doc": "This is added to the X position after being multiplied by random.nextGaussian().",
          "protocol_type": "float"
        },
        {
          "name": "offset_y",
          "doc": "This is added to the Y position after being multiplied by random.nextGaussian().",
          "protocol_type": "float"
        },
        {
          "name": "offset_z",
          "doc": "This is added to the Z position after being multiplied by random.nextGaussian().",
          "protocol_type": "float"
        },
        {
          "name": "max_speed",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "float"
        },
        {
          "name": "particle_count",
          "doc": "The number of particles to create.",
          "protocol_type": "int"
        },
        {
          "name": "particle_id",
          "doc": "The particle ID listed in Particles.",
          "protocol_type": "varint"
        },
        {
          "name": "data",
          "doc": "Particle data as specified in Particles.",
          "protocol_type": "varies"
        }
      ]
    },
    {
      "name": "UpdateLight",
      "resource": "light_update",
      "doc": "Updates light levels for a chunk. See Light for information on how lighting works in Minecraft.",
      "packet_id": 43,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "chunk_x",
          "doc": "Chunk coordinate (block coordinate divided by 16, rounded down)",
          "protocol_type": "varint"
        },
        {
          "name": "chunk_z",
          "doc": "Chunk coordinate (block coordinate divided by 16, rounded down)",
          "protocol_type": "varint"
        },
        {
          "name": "data",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "light_data"
        }
      ]
    },
    {
      "name": "PlayLogin",
      "resource": "login",
      "doc": "This section is missing information about: Although the number of portal cooldown ticks is included in this packet, the whole portal usage process is still dictated entirely by the server. What kind of effect does this value have on the client, if any?. Please expand the section to include this information. Further details may exist on the talk page.\n\nSee protocol encryption for information on logging in.",
      "packet_id": 44,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "entity_id",
          "doc": "The player's Entity ID (EID).",
          "protocol_type": "int"
        },
        {
          "name": "is_hardcore",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "boolean"
        },
        {
          "name": "dimension_names",
          "doc": "Identifiers for all dimensions on the server.",
          "protocol_type": "prefixed_array_of_identifier"
        },
        {
          "name": "max_players",
          "doc": "Was once used by the client to draw the player list, but now is ignored.",
          "protocol_type": "varint"
        },
        {
          "name": "view_distance",
          "doc": "Render distance (2-32).",
          "protocol_type": "varint"
        },
        {
          "name": "simulation_distance",
          "doc": "The distance that the client will process specific things, such as entities.",
          "protocol_type": "varint"
        },
        {
          "name": "reduced_debug_info",
          "doc": "If true, a vanilla client shows reduced information on the debug screen. For servers in development, this should almost always be false.",
          "protocol_type": "boolean"
        },
        {
          "name": "enable_respawn_screen",
          "doc": "Set to false when the doImmediateRespawn gamerule is true.",
          "protocol_type": "boolean"
        },
        {
          "name": "do_limited_crafting",
          "doc": "Whether players can only craft recipes they have already unlocked. Currently unused by the client.",
          "protocol_type": "boolean"
        },
        {
          "name": "dimension_type",
          "doc": "The ID of the type of dimension in the minecraft:dimension_type registry, defined by the Registry Data packet.",
          "protocol_type": "varint"
        },
        {
          "name": "dimension_name",
          "doc": "Name of the dimension being spawned into.",
          "protocol_type": "identifier"
        },
        {
          "name": "hashed_seed",
          "doc": "First 8 bytes of the SHA-256 hash of the world's seed. Used client side for biome noise",
          "protocol_type": "long"
        },
        {
          "name": "game_mode",
          "doc": "0: Survival, 1: Creative, 2: Adventure, 3: Spectator.",
          "protocol_type": "unsigned_byte"
        },
        {
          "name": "previous_game_mode",
          "doc": "-1: Undefined (null), 0: Survival, 1: Creative, 2: Adventure, 3: Spectator. The previous game mode. Vanilla client uses this for the debug (F3 + N& F3 + F4) game mode switch. (More information needed)",
          "protocol_type": "byte"
        },
        {
          "name": "is_debug",
          "doc": "True if the world is a debug mode world; debug mode worlds cannot be modified and have predefined blocks.",
          "protocol_type": "boolean"
        },
        {
          "name": "is_flat",
          "doc": "True if the world is a superflat world; flat worlds have different void fog and a horizon at y=0 instead of y=63.",
          "protocol_type": "boolean"
        },
        {
          "name": "has_death_location",
          "doc": "If true, then the next two fields are present.",
          "protocol_type": "boolean"
        },
        {
          "name": "death_dimension_name",
          "doc": "Name of the dimension the player died in.",
          "protocol_type": "optional_identifier"
        },
        {
          "name": "death_location",
          "doc": "The location that the player died at.",
          "protocol_type": "optional_position"
        },
        {
          "name": "portal_cooldown",
          "doc": "The number of ticks until the player can use the portal again.",
          "protocol_type": "varint"
        },
        {
          "name": "sea_level",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "varint"
        },
        {
          "name": "enforces_secure_chat",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "boolean"
        }
      ]
    },
    {
      "name": "MapData",
      "resource": "map_item_data",
      "doc": "Updates a rectangular area on a map item.",
      "packet_id": 45,
      "state": "Play",
      "clientbound": true,
      "fields": []
    },
    {
      "name": "MerchantOffers",
      "resource": "merchant_offers",
      "doc": "The list of trades a villager NPC is offering.",
      "packet_id": 46,
      "state": "Play",
      "clientbound": true,
      "fields": []
    },
    {
      "name": "UpdateEntityPosition",
      "resource": "move_entity_pos",
      "doc": "This packet is sent by the server when an entity moves a small distance. The change in position is represented as a fixed-point number with 12 fraction bits and 4 integer bits. As such, the maximum movement distance along each axis is 8 blocks in the negative direction, or 7.999755859375 blocks in the positive direction. If the movement exceeds these limits, Teleport Entity should be sent instead.",
      "packet_id": 47,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "entity_id",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "varint"
        },
        {
          "name": "delta_x",
          "doc": "Change in X position as currentX* 4096 - prevX* 4096.",
          "protocol_type": "short"
        },
        {
          "name": "delta_y",
          "doc": "Change in Y position as currentY* 4096 - prevY* 4096.",
          "protocol_type": "short"
        },
        {
          "name": "delta_z",
          "doc": "Change in Z position as currentZ* 4096 - prevZ* 4096.",
          "protocol_type": "short"
        },
        {
          "name": "on_ground",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "boolean"
        }
      ]
    },
    {
      "name": "UpdateEntityPositionandRotation",
      "resource": "move_entity_pos_rot",
      "doc": "This packet is sent by the server when an entity rotates and moves. See#Update Entity Position for how the position is encoded.",
      "packet_id": 48,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "entity_id",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "varint"
        },
        {
          "name": "delta_x",
          "doc": "Change in X position as currentX* 4096 - prevX* 4096.",
          "protocol_type": "short"
        },
        {
          "name": "delta_y",
          "doc": "Change in Y position as currentY* 4096 - prevY* 4096.",
          "protocol_type": "short"
        },
        {
          "name": "delta_z",
          "doc": "Change in Z position as currentZ* 4096 - prevZ* 4096.",
          "protocol_type": "short"
        },
        {
          "name": "yaw",
          "doc": "New angle, not a delta.",
          "protocol_type": "angle"
        },
        {
          "name": "pitch",
          "doc": "New angle, not a delta.",
          "protocol_type": "angle"
        },
        {
          "name": "on_ground",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "boolean"
        }
      ]
    },
    {
      "name": "MoveMinecartAlongTrack",
      "resource": "move_minecart_along_track",
      "doc": "Documentation is missing for this packet.",
      "packet_id": 49,
      "state": "Play",
      "clientbound": true,
      "fields": []
    },
    {
      "name": "UpdateEntityRotation",
      "resource": "move_entity_rot",
      "doc": "This packet is sent by the server when an entity rotates.",
      "packet_id": 50,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "entity_id",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "varint"
        },
        {
          "name": "yaw",
          "doc": "New angle, not a delta.",
          "protocol_type": "angle"
        },
        {
          "name": "pitch",
          "doc": "New angle, not a delta.",
          "protocol_type": "angle"
        },
        {
          "name": "on_ground",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "boolean"
        }
      ]
    },
    {
      "name": "MoveVehicle",
      "resource": "move_vehicle",
      "doc": "Note that all fields use absolute positioning and do not allow for relative positioning.",
      "packet_id": 51,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "x",
          "doc": "Absolute position (X coordinate).",
          "protocol_type": "double"
        },
        {
          "name": "y",
          "doc": "Absolute position (Y coordinate).",
          "protocol_type": "double"
        },
        {
          "name": "z",
          "doc": "Absolute position (Z coordinate).",
          "protocol_type": "double"
        },
        {
          "name": "yaw",
          "doc": "Absolute rotation on the vertical axis, in degrees.",
          "protocol_type": "float"
        },
        {
          "name": "pitch",
          "doc": "Absolute rotation on the horizontal axis, in degrees.",
          "protocol_type": "float"
        }
      ]
    },
    {
      "name": "OpenBook",
      "resource": "open_book",
      "doc": "Sent when a player right clicks with a signed book. This tells the client to open the book GUI.",
      "packet_id": 52,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "hand",
          "doc": "0: Main hand, 1: Off hand.",
          "protocol_type": "varint_enum"
        }
      ]
    },
    {
      "name": "OpenScreen",
      "resource": "open_screen",
      "doc": "This is sent to the client when it should open an inventory, such as a chest, workbench, furnace, or other container. Resending this packet with already existing window id, will update the window title and window type without closing the window.\n\nThis message is not sent to clients opening their own inventory, nor do clients inform the server in any way when doing so. From the server's perspective, the inventory is always \"open\" whenever no other windows are.\n\nFor horses, use Open Horse Screen.",
      "packet_id": 53,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "window_id",
          "doc": "An identifier for the window to be displayed. vanilla server implementation is a counter, starting at 1. There can only be one window at a time; this is only used to ignore outdated packets targeting already-closed windows. Note also that the Window ID field in most other packets is only a single byte, and indeed, the vanilla server wraps around after 100.",
          "protocol_type": "varint"
        },
        {
          "name": "window_type",
          "doc": "The window type to use for display. Contained in the minecraft:menu registry; see Inventory for the different values.",
          "protocol_type": "varint"
        },
        {
          "name": "window_title",
          "doc": "The title of the window.",
          "protocol_type": "text_component"
        }
      ]
    },
    {
      "name": "OpenSignEditor",
      "resource": "open_sign_editor",
      "doc": "Sent when the client has placed a sign and is allowed to send Update Sign. There must already be a sign at the given location (which the client does not do automatically) - send a Block Update first.",
      "packet_id": 54,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "location",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "position"
        },
        {
          "name": "is_front_text",
          "doc": "Whether the opened editor is for the front or on the back of the sign",
          "protocol_type": "boolean"
        }
      ]
    },
    {
      "name": "PlayPing",
      "resource": "ping",
      "doc": "Packet is not used by the vanilla server. When sent to the client, client responds with a Pong packet with the same id.",
      "packet_id": 55,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "id",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "int"
        }
      ]
    },
    {
      "name": "PlayPingResponse",
      "resource": "pong_response",
      "doc": "Documentation is missing for this packet.",
      "packet_id": 56,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "payload",
          "doc": "Should be the same as sent by the client.",
          "protocol_type": "long"
        }
      ]
    },
    {
      "name": "PlaceGhostRecipe",
      "resource": "place_ghost_recipe",
      "doc": "Response to the serverbound packet (Place Recipe), with the same recipe ID. Appears to be used to notify the UI.",
      "packet_id": 57,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "window_id",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "varint"
        },
        {
          "name": "recipe_display",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "recipe_display"
        }
      ]
    },
    {
      "name": "ClientboundPlayerAbilities",
      "resource": "player_abilities",
      "doc": "The latter 2 floats are used to indicate the flying speed and field of view respectively, while the first byte is used to determine the value of 4 booleans.",
      "packet_id": 58,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "flags",
          "doc": "Bit field, see below.",
          "protocol_type": "byte"
        },
        {
          "name": "flying_speed",
          "doc": "0.05 by default.",
          "protocol_type": "float"
        },
        {
          "name": "field_of_view_modifier",
          "doc": "Modifies the field of view, like a speed potion. A vanilla server will use the same value as the movement speed sent in the Update Attributes packet, which defaults to 0.1 for players.",
          "protocol_type": "float"
        }
      ]
    },
    {
      "name": "PlayerChatMessage",
      "resource": "player_chat",
      "doc": "Main article: Chat\n\nSends the client a chat message from a player.\n\nCurrently a lot is unknown about this packet, blank descriptions are for those that are unknown",
      "packet_id": 59,
      "state": "Play",
      "clientbound": true,
      "fields": []
    },
    {
      "name": "EndCombat",
      "resource": "player_combat_end",
      "doc": "Unused by the vanilla client. This data was once used for twitch.tv metadata circa 1.8.",
      "packet_id": 60,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "duration",
          "doc": "Length of the combat in ticks.",
          "protocol_type": "varint"
        }
      ]
    },
    {
      "name": "EnterCombat",
      "resource": "player_combat_enter",
      "doc": "Unused by the vanilla client. This data was once used for twitch.tv metadata circa 1.8.",
      "packet_id": 61,
      "state": "Play",
      "clientbound": true,
      "fields": []
    },
    {
      "name": "CombatDeath",
      "resource": "player_combat_kill",
      "doc": "Used to send a respawn screen.",
      "packet_id": 62,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "player_id",
          "doc": "Entity ID of the player that died (should match the client's entity ID).",
          "protocol_type": "varint"
        },
        {
          "name": "message",
          "doc": "The death message.",
          "protocol_type": "text_component"
        }
      ]
    },
    {
      "name": "PlayerInfoRemove",
      "resource": "player_info_remove",
      "doc": "Used by the server to remove players from the player list.",
      "packet_id": 63,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "uuids",
          "doc": "UUIDs of players to remove.",
          "protocol_type": "prefixed_array_of_uuid"
        }
      ]
    },
    {
      "name": "PlayerInfoUpdate",
      "resource": "player_info_update",
      "doc": "Sent by the server to update the user list (<tab> in the client).\n\nThe EnumSet type is only used here and it is currently undocumented",
      "packet_id": 64,
      "state": "Play",
      "clientbound": true,
      "fields": []
    },
    {
      "name": "LookAt",
      "resource": "player_look_at",
      "doc": "Used to rotate the client player to face the given location or entity (for/teleport [<targets>]<x><y><z> facing).",
      "packet_id": 65,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "feeteyes",
          "doc": "Values are feet=0, eyes=1. If set to eyes, aims using the head position; otherwise aims using the feet position.",
          "protocol_type": "varint_enum"
        },
        {
          "name": "target_x",
          "doc": "x coordinate of the point to face towards.",
          "protocol_type": "double"
        },
        {
          "name": "target_y",
          "doc": "y coordinate of the point to face towards.",
          "protocol_type": "double"
        },
        {
          "name": "target_z",
          "doc": "z coordinate of the point to face towards.",
          "protocol_type": "double"
        },
        {
          "name": "is_entity",
          "doc": "If true, additional information about an entity is provided.",
          "protocol_type": "boolean"
        },
        {
          "name": "entity_id",
          "doc": "Only if is entity is true — the entity to face towards.",
          "protocol_type": "optional_varint"
        },
        {
          "name": "entity_feeteyes",
          "doc": "Whether to look at the entity's eyes or feet. Same values and meanings as before, just for the entity's head/feet.",
          "protocol_type": "optional_varint_enum"
        }
      ]
    },
    {
      "name": "SynchronizePlayerPosition",
      "resource": "player_position",
      "doc": "Teleports the client, e.g. during login, when using an ender pearl, in response to invalid move packets, etc.\n\nDue to latency, the server may receive outdated movement packets sent before the client was aware of the teleport. To account for this, the server ignores all movement packets from the client until a Confirm Teleportation packet with an ID matching the one sent in the teleport packet is received.\n\nYaw is measured in degrees, and does not follow classical trigonometry rules. The unit circle of yaw on the XZ-plane starts at (0, 1) and turns counterclockwise, with 90 at (-1, 0), 180 at (0, -1) and 270 at (1, 0). Additionally, yaw is not clamped to between 0 and 360 degrees; any number is valid, including negative numbers and numbers greater than 360 (see MC-90097).\n\nPitch is measured in degrees, where 0 is looking straight ahead, -90 is looking straight up, and 90 is looking straight down.",
      "packet_id": 66,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "teleport_id",
          "doc": "Client should confirm this packet with Confirm Teleportation containing the same Teleport ID.",
          "protocol_type": "varint"
        },
        {
          "name": "x",
          "doc": "Absolute or relative position, depending on Flags.",
          "protocol_type": "double"
        },
        {
          "name": "y",
          "doc": "Absolute or relative position, depending on Flags.",
          "protocol_type": "double"
        },
        {
          "name": "z",
          "doc": "Absolute or relative position, depending on Flags.",
          "protocol_type": "double"
        },
        {
          "name": "velocity_x",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "double"
        },
        {
          "name": "velocity_y",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "double"
        },
        {
          "name": "velocity_z",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "double"
        },
        {
          "name": "yaw",
          "doc": "Absolute or relative rotation on the X axis, in degrees.",
          "protocol_type": "float"
        },
        {
          "name": "pitch",
          "doc": "Absolute or relative rotation on the Y axis, in degrees.",
          "protocol_type": "float"
        },
        {
          "name": "flags",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "teleport_flags"
        }
      ]
    },
    {
      "name": "PlayerRotation",
      "resource": "player_rotation",
      "doc": "Documentation is missing for this packet.",
      "packet_id": 67,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "yaw",
          "doc": "Rotation on the X axis, in degrees.",
          "protocol_type": "float"
        },
        {
          "name": "pitch",
          "doc": "Rotation on the Y axis, in degrees.",
          "protocol_type": "float"
        }
      ]
    },
    {
      "name": "RecipeBookAdd",
      "resource": "recipe_book_add",
      "doc": "Documentation is missing for this packet.",
      "packet_id": 68,
      "state": "Play",
      "clientbound": true,
      "fields": []
    },
    {
      "name": "RecipeBookRemove",
      "resource": "recipe_book_remove",
      "doc": "Documentation is missing for this packet.",
      "packet_id": 69,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "recipes",
          "doc": "IDs of recipes to remove.",
          "protocol_type": "prefixed_array_of_varint"
        }
      ]
    },
    {
      "name": "RecipeBookSettings",
      "resource": "recipe_book_settings",
      "doc": "Documentation is missing for this packet.",
      "packet_id": 70,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "crafting_recipe_book_open",
          "doc": "If true, then the crafting recipe book will be open when the player opens its inventory.",
          "protocol_type": "boolean"
        },
        {
          "name": "crafting_recipe_book_filter_active",
          "doc": "If true, then the filtering option is active when the players opens its inventory.",
          "protocol_type": "boolean"
        },
        {
          "name": "smelting_recipe_book_open",
          "doc": "If true, then the smelting recipe book will be open when the player opens its inventory.",
          "protocol_type": "boolean"
        },
        {
          "name": "smelting_recipe_book_filter_active",
          "doc": "If true, then the filtering option is active when the players opens its inventory.",
          "protocol_type": "boolean"
        },
        {
          "name": "blast_furnace_recipe_book_open",
          "doc": "If true, then the blast furnace recipe book will be open when the player opens its inventory.",
          "protocol_type": "boolean"
        },
        {
          "name": "blast_furnace_recipe_book_filter_active",
          "doc": "If true, then the filtering option is active when the players opens its inventory.",
          "protocol_type": "boolean"
        },
        {
          "name": "smoker_recipe_book_open",
          "doc": "If true, then the smoker recipe book will be open when the player opens its inventory.",
          "protocol_type": "boolean"
        },
        {
          "name": "smoker_recipe_book_filter_active",
          "doc": "If true, then the filtering option is active when the players opens its inventory.",
          "protocol_type": "boolean"
        }
      ]
    },
    {
      "name": "RemoveEntities",
      "resource": "remove_entities",
      "doc": "Sent by the server when an entity is to be destroyed on the client.",
      "packet_id": 71,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "entity_ids",
          "doc": "The list of entities to destroy.",
          "protocol_type": "prefixed_array_of_varint"
        }
      ]
    },
    {
      "name": "RemoveEntityEffect",
      "resource": "remove_mob_effect",
      "doc": "Documentation is missing for this packet.",
      "packet_id": 72,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "entity_id",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "varint"
        },
        {
          "name": "effect_id",
          "doc": "See this table.",
          "protocol_type": "varint"
        }
      ]
    },
    {
      "name": "ResetScore",
      "resource": "reset_score",
      "doc": "This is sent to the client when it should remove a scoreboard item.",
      "packet_id": 73,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "entity_name",
          "doc": "The entity whose score this is. For players, this is their username; for other entities, it is their UUID.",
          "protocol_type": "string"
        },
        {
          "name": "objective_name",
          "doc": "The name of the objective the score belongs to.",
          "protocol_type": "prefixed_optional_string"
        }
      ]
    },
    {
      "name": "PlayRemoveResourcePack",
      "resource": "resource_pack_pop",
      "doc": "Documentation is missing for this packet.",
      "packet_id": 74,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "uuid",
          "doc": "The UUID of the resource pack to be removed.",
          "protocol_type": "optional_uuid"
        }
      ]
    },
    {
      "name": "PlayAddResourcePack",
      "resource": "resource_pack_push",
      "doc": "Documentation is missing for this packet.",
      "packet_id": 75,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "uuid",
          "doc": "The unique identifier of the resource pack.",
          "protocol_type": "uuid"
        },
        {
          "name": "url",
          "doc": "The URL to the resource pack.",
          "protocol_type": "string"
        },
        {
          "name": "hash",
          "doc": "A 40 character hexadecimal, case-insensitive SHA-1 hash of the resource pack file. If it's not a 40 character hexadecimal string, the client will not use it for hash verification and likely waste bandwidth.",
          "protocol_type": "string"
        },
        {
          "name": "forced",
          "doc": "The vanilla client will be forced to use the resource pack from the server. If they decline they will be kicked from the server.",
          "protocol_type": "boolean"
        },
        {
          "name": "prompt_message",
          "doc": "This is shown in the prompt making the client accept or decline the resource pack.",
          "protocol_type": "prefixed_optional_text_component"
        }
      ]
    },
    {
      "name": "Respawn",
      "resource": "respawn",
      "doc": "This section is missing information about: Although the number of portal cooldown ticks is included in this packet, the whole portal usage process is still dictated entirely by the server. What kind of effect does this value have on the client, if any?. Please expand the section to include this information. Further details may exist on the talk page.\n\nTo change the player's dimension (overworld/nether/end), send them a respawn packet with the appropriate dimension, followed by prechunks/chunks for the new dimension, and finally a position and look packet. You do not need to unload chunks, the client will do it automatically.",
      "packet_id": 76,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "dimension_type",
          "doc": "The ID of type of dimension in the minecraft:dimension_type registry, defined by the Registry Data packet.",
          "protocol_type": "varint"
        },
        {
          "name": "dimension_name",
          "doc": "Name of the dimension being spawned into.",
          "protocol_type": "identifier"
        },
        {
          "name": "hashed_seed",
          "doc": "First 8 bytes of the SHA-256 hash of the world's seed. Used client side for biome noise",
          "protocol_type": "long"
        },
        {
          "name": "game_mode",
          "doc": "0: Survival, 1: Creative, 2: Adventure, 3: Spectator.",
          "protocol_type": "unsigned_byte"
        },
        {
          "name": "previous_game_mode",
          "doc": "-1: Undefined (null), 0: Survival, 1: Creative, 2: Adventure, 3: Spectator. The previous game mode. Vanilla client uses this for the debug (F3 + N& F3 + F4) game mode switch. (More information needed)",
          "protocol_type": "byte"
        },
        {
          "name": "is_debug",
          "doc": "True if the world is a debug mode world; debug mode worlds cannot be modified and have predefined blocks.",
          "protocol_type": "boolean"
        },
        {
          "name": "is_flat",
          "doc": "True if the world is a superflat world; flat worlds have different void fog and a horizon at y=0 instead of y=63.",
          "protocol_type": "boolean"
        },
        {
          "name": "has_death_location",
          "doc": "If true, then the next two fields are present.",
          "protocol_type": "boolean"
        },
        {
          "name": "death_dimension_name",
          "doc": "Name of the dimension the player died in.",
          "protocol_type": "optional_identifier"
        },
        {
          "name": "death_location",
          "doc": "The location that the player died at.",
          "protocol_type": "optional_position"
        },
        {
          "name": "portal_cooldown",
          "doc": "The number of ticks until the player can use the portal again.",
          "protocol_type": "varint"
        },
        {
          "name": "sea_level",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "varint"
        },
        {
          "name": "data_kept",
          "doc": "Bit mask. 0x01: Keep attributes, 0x02: Keep metadata. Tells which data should be kept on the client side once the player has respawned. In the vanilla implementation, this is context dependent: normal respawns (after death) keep no data; exiting the end poem/credits keeps the attributes; other dimension changes (portals or teleports) keep all data.",
          "protocol_type": "byte"
        }
      ]
    },
    {
      "name": "SetHeadRotation",
      "resource": "rotate_head",
      "doc": "Changes the direction an entity's head is facing.\n\nWhile sending the Entity Look packet changes the vertical rotation of the head, sending this packet appears to be necessary to rotate the head horizontally.",
      "packet_id": 77,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "entity_id",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "varint"
        },
        {
          "name": "head_yaw",
          "doc": "New angle, not a delta.",
          "protocol_type": "angle"
        }
      ]
    },
    {
      "name": "UpdateSectionBlocks",
      "resource": "section_blocks_update",
      "doc": "Fired whenever 2 or more blocks are changed within the same chunk on the same tick.\n\nChanging blocks in chunks not loaded by the client is unsafe (see note on Block Update).",
      "packet_id": 78,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "chunk_section_position",
          "doc": "Chunk section coordinate (encoded chunk x and z with each 22 bits, and section y with 20 bits, from left to right).",
          "protocol_type": "long"
        },
        {
          "name": "blocks",
          "doc": "Each entry is composed of the block state id, shifted left by 12, and the relative block position in the chunk section (4 bits for x, z, and y, from left to right).",
          "protocol_type": "prefixed_array_of_varlong"
        }
      ]
    },
    {
      "name": "SelectAdvancementsTab",
      "resource": "select_advancements_tab",
      "doc": "Sent by the server to indicate that the client should switch advancement tab. Sent either when the client switches tab in the GUI or when an advancement in another tab is made.",
      "packet_id": 79,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "identifier",
          "doc": "See below.",
          "protocol_type": "prefixed_optional_identifier"
        }
      ]
    },
    {
      "name": "ServerData",
      "resource": "server_data",
      "doc": "Documentation is missing for this packet.",
      "packet_id": 80,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "motd",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "text_component"
        },
        {
          "name": "icon",
          "doc": "Icon bytes in the PNG format.",
          "protocol_type": "prefixed_optional_prefixed_array_of_byte"
        }
      ]
    },
    {
      "name": "SetActionBarText",
      "resource": "set_action_bar_text",
      "doc": "Displays a message above the hotbar. Equivalent to System Chat Message with Overlay set to true, except that chat message blocking isn't performed. Used by the vanilla server only to implement the/title command.",
      "packet_id": 81,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "action_bar_text",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "text_component"
        }
      ]
    },
    {
      "name": "SetBorderCenter",
      "resource": "set_border_center",
      "doc": "Documentation is missing for this packet.",
      "packet_id": 82,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "x",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "double"
        },
        {
          "name": "z",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "double"
        }
      ]
    },
    {
      "name": "SetBorderLerpSize",
      "resource": "set_border_lerp_size",
      "doc": "Documentation is missing for this packet.",
      "packet_id": 83,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "old_diameter",
          "doc": "Current length of a single side of the world border, in meters.",
          "protocol_type": "double"
        },
        {
          "name": "new_diameter",
          "doc": "Target length of a single side of the world border, in meters.",
          "protocol_type": "double"
        },
        {
          "name": "speed",
          "doc": "Number of real-time milli seconds until New Diameter is reached. It appears that vanilla server does not sync world border speed to game ticks, so it gets out of sync with server lag. If the world border is not moving, this is set to 0.",
          "protocol_type": "varlong"
        }
      ]
    },
    {
      "name": "SetBorderSize",
      "resource": "set_border_size",
      "doc": "Documentation is missing for this packet.",
      "packet_id": 84,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "diameter",
          "doc": "Length of a single side of the world border, in meters.",
          "protocol_type": "double"
        }
      ]
    },
    {
      "name": "SetBorderWarningDelay",
      "resource": "set_border_warning_delay",
      "doc": "Documentation is missing for this packet.",
      "packet_id": 85,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "warning_time",
          "doc": "In seconds as set by/worldborder warning time.",
          "protocol_type": "varint"
        }
      ]
    },
    {
      "name": "SetBorderWarningDistance",
      "resource": "set_border_warning_distance",
      "doc": "Documentation is missing for this packet.",
      "packet_id": 86,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "warning_blocks",
          "doc": "In meters.",
          "protocol_type": "varint"
        }
      ]
    },
    {
      "name": "SetCamera",
      "resource": "set_camera",
      "doc": "Sets the entity that the player renders from. This is normally used when the player left-clicks an entity while in spectator mode.\n\nThe player's camera will move with the entity and look where it is looking. The entity is often another player, but can be any type of entity. The player is unable to move this entity (move packets will act as if they are coming from the other entity).\n\nIf the given entity is not loaded by the player, this packet is ignored. To return control to the player, send this packet with their entity ID.\n\nThe vanilla server resets this (sends it back to the default entity) whenever the spectated entity is killed or the player sneaks, but only if they were spectating an entity. It also sends this packet whenever the player switches out of spectator mode (even if they weren't spectating an entity).",
      "packet_id": 87,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "camera_id",
          "doc": "ID of the entity to set the client's camera to.",
          "protocol_type": "varint"
        }
      ]
    },
    {
      "name": "SetCenterChunk",
      "resource": "set_chunk_cache_center",
      "doc": "Sets the center position of the client's chunk loading area. The area is square-shaped, spanning 2 × server view distance + 7 chunks on both axes (width, not radius!). Since the area's width is always an odd number, there is no ambiguity as to which chunk is the center.\n\nThe vanilla client ignores attempts to send chunks located outside the loading area, and immediately unloads any existing chunks no longer inside it.\n\nThe center chunk is normally the chunk the player is in, but apart from the implications on chunk loading, the (vanilla) client takes no issue with this not being the case. Indeed, as long as chunks are sent only within the default loading area centered on the world origin, it is not necessary to send this packet at all. This may be useful for servers with small bounded worlds, such as minigames, since it ensures chunks never need to be resent after the client has joined, saving on bandwidth.\n\nThe vanilla server sends this packet whenever the player moves across a chunk border horizontally, and also (according to testing) for any integer change in the vertical axis, even if it doesn't go across a chunk section border.",
      "packet_id": 88,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "chunk_x",
          "doc": "Chunk X coordinate of the loading area center.",
          "protocol_type": "varint"
        },
        {
          "name": "chunk_z",
          "doc": "Chunk Z coordinate of the loading area center.",
          "protocol_type": "varint"
        }
      ]
    },
    {
      "name": "SetRenderDistance",
      "resource": "set_chunk_cache_radius",
      "doc": "Sent by the integrated singleplayer server when changing render distance. This packet is sent by the server when the client reappears in the overworld after leaving the end.",
      "packet_id": 89,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "view_distance",
          "doc": "Render distance (2-32).",
          "protocol_type": "varint"
        }
      ]
    },
    {
      "name": "SetCursorItem",
      "resource": "set_cursor_item",
      "doc": "Replaces or sets the inventory item that's being dragged with the mouse.",
      "packet_id": 90,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "carried_item",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "slot"
        }
      ]
    },
    {
      "name": "SetDefaultSpawnPosition",
      "resource": "set_default_spawn_position",
      "doc": "Sent by the server after login to specify the coordinates of the spawn point (the point at which players spawn at, and which the compass points to). It can be sent at any time to update the point compasses point at.\n\nThe client uses this as the default position of the player upon spawning, though it's a good idea to always override this default by sending Synchronize Player Position. When converting the position to floating point, 0.5 is added to the x and z coordinates and 1.0 to the y coordinate, so as to place the player centered on top of the specified block position.\n\nBefore receiving this packet, the client uses the default position 8, 64, 8, and angle 0.0 (resulting in a default player spawn position of 8.5, 65.0, 8.5).",
      "packet_id": 91,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "location",
          "doc": "Spawn location.",
          "protocol_type": "position"
        },
        {
          "name": "angle",
          "doc": "The angle at which to respawn at.",
          "protocol_type": "float"
        }
      ]
    },
    {
      "name": "DisplayObjective",
      "resource": "set_display_objective",
      "doc": "This is sent to the client when it should display a scoreboard.",
      "packet_id": 92,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "position",
          "doc": "The position of the scoreboard. 0: list, 1: sidebar, 2: below name, 3 - 18: team specific sidebar, indexed as 3 + team color.",
          "protocol_type": "varint"
        },
        {
          "name": "score_name",
          "doc": "The unique name for the scoreboard to be displayed.",
          "protocol_type": "string"
        }
      ]
    },
    {
      "name": "SetEntityMetadata",
      "resource": "set_entity_data",
      "doc": "Updates one or more metadata properties for an existing entity. Any properties not included in the Metadata field are left unchanged.",
      "packet_id": 93,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "entity_id",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "varint"
        },
        {
          "name": "metadata",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "entity_metadata"
        }
      ]
    },
    {
      "name": "LinkEntities",
      "resource": "set_entity_link",
      "doc": "This packet is sent when an entity has been leashed to another entity.",
      "packet_id": 94,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "attached_entity_id",
          "doc": "Attached entity's EID.",
          "protocol_type": "int"
        },
        {
          "name": "holding_entity_id",
          "doc": "ID of the entity holding the lead. Set to -1 to detach.",
          "protocol_type": "int"
        }
      ]
    },
    {
      "name": "SetEntityVelocity",
      "resource": "set_entity_motion",
      "doc": "Velocity is in units of 1/8000 of a block per server tick (50ms); for example, -1343 would move (-1343/ 8000) = −0.167875 blocks per tick (or −3.3575 blocks per second).",
      "packet_id": 95,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "entity_id",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "varint"
        },
        {
          "name": "velocity_x",
          "doc": "Velocity on the X axis.",
          "protocol_type": "short"
        },
        {
          "name": "velocity_y",
          "doc": "Velocity on the Y axis.",
          "protocol_type": "short"
        },
        {
          "name": "velocity_z",
          "doc": "Velocity on the Z axis.",
          "protocol_type": "short"
        }
      ]
    },
    {
      "name": "SetEquipment",
      "resource": "set_equipment",
      "doc": "Documentation is missing for this packet.",
      "packet_id": 96,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "entity_id",
          "doc": "Entity's ID.",
          "protocol_type": "varint"
        },
        {
          "name": "equipment",
          "doc": "The length of the array is unknown, it must be read until the most significant bit is 1 ((Slot>>> 7& 1) == 1)",
          "protocol_type": "array"
        },
        {
          "name": "slot",
          "doc": "Equipment slot (see below). Also has the top bit set if another entry follows, and otherwise unset if this is the last item in the array.",
          "protocol_type": "byte_enum"
        }
      ]
    },
    {
      "name": "SetExperience",
      "resource": "set_experience",
      "doc": "Sent by the server when the client should change experience levels.",
      "packet_id": 97,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "experience_bar",
          "doc": "Between 0 and 1.",
          "protocol_type": "float"
        },
        {
          "name": "level",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "varint"
        },
        {
          "name": "total_experience",
          "doc": "See Experience#Leveling up on the Minecraft Wiki for Total Experience to Level conversion.",
          "protocol_type": "varint"
        }
      ]
    },
    {
      "name": "SetHealth",
      "resource": "set_health",
      "doc": "Sent by the server to set the health of the player it is sent to.\n\nFood saturation acts as a food “overcharge”. Food values will not decrease while the saturation is over zero. New players logging in or respawning automatically get a saturation of 5.0. Eating food increases the saturation as well as the food bar.",
      "packet_id": 98,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "health",
          "doc": "0 or less = dead, 20 = full HP.",
          "protocol_type": "float"
        },
        {
          "name": "food",
          "doc": "0–20.",
          "protocol_type": "varint"
        },
        {
          "name": "food_saturation",
          "doc": "Seems to vary from 0.0 to 5.0 in integer increments.",
          "protocol_type": "float"
        }
      ]
    },
    {
      "name": "ClientboundSetHeldItem",
      "resource": "set_held_slot",
      "doc": "Sent to change the player's slot selection.",
      "packet_id": 99,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "slot",
          "doc": "The slot which the player has selected (0–8).",
          "protocol_type": "varint"
        }
      ]
    },
    {
      "name": "UpdateObjectives",
      "resource": "set_objective",
      "doc": "This is sent to the client when it should create a new scoreboard objective or remove one.",
      "packet_id": 100,
      "state": "Play",
      "clientbound": true,
      "fields": []
    },
    {
      "name": "SetPassengers",
      "resource": "set_passengers",
      "doc": "Documentation is missing for this packet.",
      "packet_id": 101,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "entity_id",
          "doc": "Vehicle's EID.",
          "protocol_type": "varint"
        },
        {
          "name": "passengers",
          "doc": "EIDs of entity's passengers.",
          "protocol_type": "prefixed_array_of_varint"
        }
      ]
    },
    {
      "name": "SetPlayerInventorySlot",
      "resource": "set_player_inventory",
      "doc": "Documentation is missing for this packet.",
      "packet_id": 102,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "slot",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "varint"
        },
        {
          "name": "slot_data",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "slot"
        }
      ]
    },
    {
      "name": "UpdateTeams",
      "resource": "set_player_team",
      "doc": "Creates and updates teams.",
      "packet_id": 103,
      "state": "Play",
      "clientbound": true,
      "fields": []
    },
    {
      "name": "UpdateScore",
      "resource": "set_score",
      "doc": "This is sent to the client when it should update a scoreboard item.",
      "packet_id": 104,
      "state": "Play",
      "clientbound": true,
      "fields": []
    },
    {
      "name": "SetSimulationDistance",
      "resource": "set_simulation_distance",
      "doc": "Documentation is missing for this packet.",
      "packet_id": 105,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "simulation_distance",
          "doc": "The distance that the client will process specific things, such as entities.",
          "protocol_type": "varint"
        }
      ]
    },
    {
      "name": "SetSubtitleText",
      "resource": "set_subtitle_text",
      "doc": "Documentation is missing for this packet.",
      "packet_id": 106,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "subtitle_text",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "text_component"
        }
      ]
    },
    {
      "name": "UpdateTime",
      "resource": "set_time",
      "doc": "Time is based on ticks, where 20 ticks happen every second. There are 24000 ticks in a day, making Minecraft days exactly 20 minutes long.\n\nThe time of day is based on the timestamp modulo 24000. 0 is sunrise, 6000 is noon, 12000 is sunset, and 18000 is midnight.\n\nThe default SMP server increments the time by 20 every second.",
      "packet_id": 107,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "world_age",
          "doc": "In ticks; not changed by server commands.",
          "protocol_type": "long"
        },
        {
          "name": "time_of_day",
          "doc": "The world (or region) time, in ticks.",
          "protocol_type": "long"
        },
        {
          "name": "time_of_day_increasing",
          "doc": "If true, the client should automatically advance the time of day according to its ticking rate.",
          "protocol_type": "boolean"
        }
      ]
    },
    {
      "name": "SetTitleText",
      "resource": "set_title_text",
      "doc": "Documentation is missing for this packet.",
      "packet_id": 108,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "title_text",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "text_component"
        }
      ]
    },
    {
      "name": "SetTitleAnimationTimes",
      "resource": "set_titles_animation",
      "doc": "Documentation is missing for this packet.",
      "packet_id": 109,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "fade_in",
          "doc": "Ticks to spend fading in.",
          "protocol_type": "int"
        },
        {
          "name": "stay",
          "doc": "Ticks to keep the title displayed.",
          "protocol_type": "int"
        },
        {
          "name": "fade_out",
          "doc": "Ticks to spend fading out, not when to start fading out.",
          "protocol_type": "int"
        }
      ]
    },
    {
      "name": "EntitySoundEffect",
      "resource": "sound_entity",
      "doc": "Plays a sound effect from an entity, either by hardcoded ID or Identifier. Sound IDs and names can be found here.",
      "packet_id": 110,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "sound_event",
          "doc": "ID in the minecraft:sound_event registry, or an inline definition.",
          "protocol_type": "id_or_sound_event"
        },
        {
          "name": "sound_category",
          "doc": "The category that this sound will be played from (current categories).",
          "protocol_type": "varint_enum"
        },
        {
          "name": "entity_id",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "varint"
        },
        {
          "name": "volume",
          "doc": "1.0 is 100%, capped between 0.0 and 1.0 by vanilla clients.",
          "protocol_type": "float"
        },
        {
          "name": "pitch",
          "doc": "Float between 0.5 and 2.0 by vanilla clients.",
          "protocol_type": "float"
        },
        {
          "name": "seed",
          "doc": "Seed used to pick sound variant.",
          "protocol_type": "long"
        }
      ]
    },
    {
      "name": "SoundEffect",
      "resource": "sound",
      "doc": "Plays a sound effect at the given location, either by hardcoded ID or Identifier. Sound IDs and names can be found here.",
      "packet_id": 111,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "sound_event",
          "doc": "ID in the minecraft:sound_event registry, or an inline definition.",
          "protocol_type": "id_or_sound_event"
        },
        {
          "name": "sound_category",
          "doc": "The category that this sound will be played from (current categories).",
          "protocol_type": "varint_enum"
        },
        {
          "name": "effect_position_x",
          "doc": "Effect X multiplied by 8 (fixed-point number with only 3 bits dedicated to the fractional part).",
          "protocol_type": "int"
        },
        {
          "name": "effect_position_y",
          "doc": "Effect Y multiplied by 8 (fixed-point number with only 3 bits dedicated to the fractional part).",
          "protocol_type": "int"
        },
        {
          "name": "effect_position_z",
          "doc": "Effect Z multiplied by 8 (fixed-point number with only 3 bits dedicated to the fractional part).",
          "protocol_type": "int"
        },
        {
          "name": "volume",
          "doc": "1.0 is 100%, capped between 0.0 and 1.0 by vanilla clients.",
          "protocol_type": "float"
        },
        {
          "name": "pitch",
          "doc": "Float between 0.5 and 2.0 by vanilla clients.",
          "protocol_type": "float"
        },
        {
          "name": "seed",
          "doc": "Seed used to pick sound variant.",
          "protocol_type": "long"
        }
      ]
    },
    {
      "name": "StartConfiguration",
      "resource": "start_configuration",
      "doc": "Sent during gameplay in order to redo the configuration process. The client must respond with Acknowledge Configuration for the process to start.",
      "packet_id": 112,
      "state": "Play",
      "clientbound": true,
      "fields": []
    },
    {
      "name": "StopSound",
      "resource": "stop_sound",
      "doc": "Documentation is missing for this packet.",
      "packet_id": 113,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "flags",
          "doc": "Controls which fields are present.",
          "protocol_type": "byte"
        },
        {
          "name": "source",
          "doc": "Only if flags is 3 or 1 (bit mask 0x1). See below. If not present, then sounds from all sources are cleared.",
          "protocol_type": "optional_varint_enum"
        },
        {
          "name": "sound",
          "doc": "Only if flags is 2 or 3 (bit mask 0x2). A sound effect name, see Custom Sound Effect. If not present, then all sounds are cleared.",
          "protocol_type": "optional_identifier"
        }
      ]
    },
    {
      "name": "PlayStoreCookie",
      "resource": "store_cookie",
      "doc": "Stores some arbitrary data on the client, which persists between server transfers. The vanilla client only accepts cookies of up to 5 kiB in size.",
      "packet_id": 114,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "key",
          "doc": "The identifier of the cookie.",
          "protocol_type": "identifier"
        },
        {
          "name": "payload",
          "doc": "The data of the cookie.",
          "protocol_type": "prefixed_array_of_byte"
        }
      ]
    },
    {
      "name": "SystemChatMessage",
      "resource": "system_chat",
      "doc": "Main article: Chat\n\nSends the client a raw system message.",
      "packet_id": 115,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "content",
          "doc": "Limited to 262144 bytes.",
          "protocol_type": "text_component"
        },
        {
          "name": "overlay",
          "doc": "Whether the message is an actionbar or chat message. See also#Set Action Bar Text.",
          "protocol_type": "boolean"
        }
      ]
    },
    {
      "name": "SetTabListHeaderAndFooter",
      "resource": "tab_list",
      "doc": "This packet may be used by custom servers to display additional information above/below the player list. It is never sent by the vanilla server.",
      "packet_id": 116,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "header",
          "doc": "To remove the header, send a empty text component: {\"text\":\"\"}.",
          "protocol_type": "text_component"
        },
        {
          "name": "footer",
          "doc": "To remove the footer, send a empty text component: {\"text\":\"\"}.",
          "protocol_type": "text_component"
        }
      ]
    },
    {
      "name": "TagQueryResponse",
      "resource": "tag_query",
      "doc": "Sent in response to Query Block Entity Tag or Query Entity Tag.",
      "packet_id": 117,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "transaction_id",
          "doc": "Can be compared to the one sent in the original query packet.",
          "protocol_type": "varint"
        },
        {
          "name": "nbt",
          "doc": "The NBT of the block or entity. May be a TAG_END (0) in which case no NBT is present.",
          "protocol_type": "nbt"
        }
      ]
    },
    {
      "name": "PickupItem",
      "resource": "take_item_entity",
      "doc": "Sent by the server when someone picks up an item lying on the ground — its sole purpose appears to be the animation of the item flying towards you. It doesn't destroy the entity in the client memory, and it doesn't add it to your inventory. The server only checks for items to be picked up after each Set Player Position (and Set Player Position And Rotation) packet sent by the client. The collector entity can be any entity; it does not have to be a player. The collected entity also can be any entity, but the vanilla server only uses this for items, experience orbs, and the different varieties of arrows.",
      "packet_id": 118,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "collected_entity_id",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "varint"
        },
        {
          "name": "collector_entity_id",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "varint"
        },
        {
          "name": "pickup_item_count",
          "doc": "Seems to be 1 for XP orbs, otherwise the number of items in the stack.",
          "protocol_type": "varint"
        }
      ]
    },
    {
      "name": "SynchronizeVehiclePosition",
      "resource": "teleport_entity",
      "doc": "Teleports the entity on the client without changing the reference point of movement deltas in future Update Entity Position packets. Seems to be used to make relative adjustments to vehicle positions; more information needed.",
      "packet_id": 119,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "entity_id",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "varint"
        },
        {
          "name": "x",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "double"
        },
        {
          "name": "y",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "double"
        },
        {
          "name": "z",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "double"
        },
        {
          "name": "velocity_x",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "double"
        },
        {
          "name": "velocity_y",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "double"
        },
        {
          "name": "velocity_z",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "double"
        },
        {
          "name": "yaw",
          "doc": "Rotation on the Y axis, in degrees.",
          "protocol_type": "float"
        },
        {
          "name": "pitch",
          "doc": "Rotation on the Y axis, in degrees.",
          "protocol_type": "float"
        },
        {
          "name": "flags",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "teleport_flags"
        },
        {
          "name": "on_ground",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "boolean"
        }
      ]
    },
    {
      "name": "SetTickingState",
      "resource": "ticking_state",
      "doc": "Used to adjust the ticking rate of the client, and whether it's frozen.",
      "packet_id": 120,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "tick_rate",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "float"
        },
        {
          "name": "is_frozen",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "boolean"
        }
      ]
    },
    {
      "name": "StepTick",
      "resource": "ticking_step",
      "doc": "Advances the client processing by the specified number of ticks. Has no effect unless client ticking is frozen.",
      "packet_id": 121,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "tick_steps",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "varint"
        }
      ]
    },
    {
      "name": "PlayTransfer",
      "resource": "transfer",
      "doc": "Notifies the client that it should transfer to the given server. Cookies previously stored are preserved between server transfers.",
      "packet_id": 122,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "host",
          "doc": "The hostname or IP of the server.",
          "protocol_type": "string"
        },
        {
          "name": "port",
          "doc": "The port of the server.",
          "protocol_type": "varint"
        }
      ]
    },
    {
      "name": "UpdateAdvancements",
      "resource": "update_advancements",
      "doc": "Documentation is missing for this packet.",
      "packet_id": 123,
      "state": "Play",
      "clientbound": true,
      "fields": []
    },
    {
      "name": "UpdateAttributes",
      "resource": "update_attributes",
      "doc": "Sets attributes on the given entity.",
      "packet_id": 124,
      "state": "Play",
      "clientbound": true,
      "fields": []
    },
    {
      "name": "EntityEffect",
      "resource": "update_mob_effect",
      "doc": "Documentation is missing for this packet.",
      "packet_id": 125,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "entity_id",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "varint"
        },
        {
          "name": "effect_id",
          "doc": "See this table.",
          "protocol_type": "varint"
        },
        {
          "name": "amplifier",
          "doc": "Vanilla client displays effect level as Amplifier + 1.",
          "protocol_type": "varint"
        },
        {
          "name": "duration",
          "doc": "Duration in ticks. (-1 for infinite)",
          "protocol_type": "varint"
        },
        {
          "name": "flags",
          "doc": "Bit field, see below.",
          "protocol_type": "byte"
        }
      ]
    },
    {
      "name": "UpdateRecipes",
      "resource": "update_recipes",
      "doc": "Documentation is missing for this packet.",
      "packet_id": 126,
      "state": "Play",
      "clientbound": true,
      "fields": []
    },
    {
      "name": "PlayUpdateTags",
      "resource": "update_tags",
      "doc": "Documentation is missing for this packet.",
      "packet_id": 127,
      "state": "Play",
      "clientbound": true,
      "fields": []
    },
    {
      "name": "ProjectilePower",
      "resource": "projectile_power",
      "doc": "Documentation is missing for this packet.",
      "packet_id": 128,
      "state": "Play",
      "clientbound": true,
      "fields": [
        {
          "name": "entity_id",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "varint"
        },
        {
          "name": "power",
          "doc": "Documentation is missing for this field.",
          "protocol_type": "double"
        }
      ]
    },
    {
      "name": "CustomReportDetails",
      "resource": "custom_report_details",
      "doc": "Contains a list of key-value text entries that are included in any crash or disconnection report generated during connection to the server.",
      "packet_id": 129,
      "state": "Play",
      "clientbound": true,
      "fields": []
    },
    {
      "name": "ServerLinks",
      "resource": "server_links",
      "doc": "This packet contains a list of links that the vanilla client will display in the menu available from the pause menu. Link labels can be built-in or custom (i.e., any text).",
      "packet_id": 130,
      "state": "Play",
      "clientbound": true,
      "fields": []
    },
    {
      "name": "StatusRequest",
      "resource": "status_request",
      "doc": "The status can only be requested once immediately after the handshake, before any ping. The server won't respond otherwise.",
      "packet_id": 0,
      "state": "Status",
      "clientbound": false,
      "fields": []
    },
    {
      "name": "StatusPingRequest",
      "resource": "ping_request",
      "doc": "Documentation is missing for this packet.",
      "packet_id": 1,
      "state": "Status",
      "clientbound": false,
      "fields": [
        {
          "name": "timestamp",
          "doc": "May be any number, but vanilla clients use will always use the timestamp in milliseconds.",
          "protocol_type": "long"
        }
      ]
    },
    {
      "name": "StatusResponse",
      "resource": "status_response",
      "doc": "Documentation is missing for this packet.",
      "packet_id": 0,
      "state": "Status",
      "clientbound": true,
      "fields": [
        {
          "name": "json_response",
          "doc": "See Server List Ping#Status Response; as with all strings this is prefixed by its length as a VarInt.",
          "protocol_type": "string"
        }
      ]
    },
    {
      "name": "StatusPongResponse",
      "resource": "pong_response",
      "doc": "Documentation is missing for this packet.",
      "packet_id": 1,
      "state": "Status",
      "clientbound": true,
      "fields": [
        {
          "name": "timestamp",
          "doc": "Should match the one sent by the client.",
          "protocol_type": "long"
        }
      ]
    }
  ],
  "packet_data": [
    {
      "name": "LoginProperty",
      "doc": "Some data sent by the client to the server in a LoginSuccess packet.",
      "fields": [
        {
          "name": "name",
          "doc": "The name of this property. each player will usually have one property with Name being “textures” and Value being a base64-encoded JSON string, as documented [here](https://minecraft.wiki/w/Minecraft_Wiki:Projects/wiki.vg_merge/Mojang_API#UUID_to_Profile_and_Skin/Cape)",
          "protocol_type": "string"
        },
        {
          "name": "value",
          "doc": "The value corresponding to `name`.",
          "protocol_type": "string"
        },
        {
          "name": "signature",
          "doc": "The signature corresponding to the data held in `value`.",
          "protocol_type": "prefixed_optional_string"
        }
      ]
    }
  ]
}