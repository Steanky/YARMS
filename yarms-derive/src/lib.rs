//!
//! This crate includes a derive macro for generating `Packet` implementations automatically from
//! structs whose fields consist only of types with an existing `ProtocolRead` and `ProtocolWrite`
//! implementation.
//!
//! It also has a macro for generating `ProtocolRead` and `ProtocolWrite` implementations on structs
//! whose fields consist entirely of ProtocolTypes themselves.
//!
//! This code generated by these procedural macros assumes the presence of the `yarms-protocol`,
//! `yarms-packet`, and `bytes` crates.

extern crate proc_macro;

use proc_macro::TokenStream;
use quote::{quote, ToTokens};
use syn::spanned::Spanned;
use syn::visit::Visit;
use syn::visit_mut::VisitMut;

///
/// All the arguments needed to generate an implementation of a certain trait on a struct.
type Args<'a> = (
    &'a mut syn::DataStruct,
    &'a syn::Ident,
    &'a mut syn::Generics,
    &'a [syn::Attribute],
);

///
/// Automatically generate a Packet implementation for any data struct.
///
/// The struct must also supply the `packet_id` attribute. This is the "protocol identifier" for the
/// packet. Similarly, it must also supply `clientbound` and `resource`.
///
/// # Example
/// ```ignore
///
/// #[derive(Packet)] // generates a `Packet` implementation on the struct
/// #[packet_id(42)]
/// #[resource("example_packet")]
/// #[clientbound(true)] // this packet is sent from the server to the client
/// struct ExamplePacket {
///     // OK: yarms_protocol::types::VarInt implements both ProtocolRead and ProtocolWrite
///     example_field: yarms_protocol::types::VarInt,
///
///     // not OK: this type can't be sent to/read from a buffer
///     // invalid_field: Arc<Mutex<File>>
/// }
/// ```
///
/// The code generated by this macro requires the `yarms-protocol`, `yarms-packet`, and `bytes`
/// crates.
#[proc_macro_derive(Packet, attributes(packet_id, clientbound, resource))]
pub fn packet_derive(item: TokenStream) -> TokenStream {
    let mut input = syn::parse_macro_input!(item as syn::DeriveInput);

    require_data_struct(&mut input)
        .and_then(packet_struct_impl)
        .unwrap_or_else(|error| error.into_compile_error().into())
}

///
/// Automatically generates a ProtocolRead and ProtocolWrite implementation.
///
/// # Example
/// ```ignore
///
/// #[derive(Protocol)]
/// struct Example<'a> {
///     value: ::yarms_protocol::types::VarInt,
///     name: ::alloc::borrow::Cow<'a, str>
/// }
/// ```
#[proc_macro_derive(Protocol)]
pub fn protocol_derive(item: TokenStream) -> TokenStream {
    let mut input = syn::parse_macro_input!(item as syn::DeriveInput);

    require_data_struct(&mut input)
        .and_then(protocol_struct_impl)
        .unwrap_or_else(|error| error.into_compile_error().into())
}

macro_rules! find_lit_attr {
    ($variant:ident, $struct_name:expr, $attr_path:literal, $struct_attrs:expr) => {{
        let __name = ($struct_name);
        let __attrs = ($struct_attrs);

        (__attrs)
            .iter()
            .find(|attr| attr.path().is_ident($attr_path))
            .map_or_else(
                || {
                    Err(::syn::Error::new(
                        __name.span(),
                        concat!("missing required attribute `", $attr_path, "`"),
                    ))
                },
                ::syn::Attribute::parse_args::<::syn::ExprLit>,
            )
            .map(|lit| lit.lit)
            .and_then(|lit| match lit {
                syn::Lit::$variant(inner) => Ok(inner),
                other => Err(::syn::Error::new(
                    __name.span(),
                    concat!("expected `", stringify!($variant), "`"),
                )),
            })
    }};
}

fn require_data_struct(input: &mut syn::DeriveInput) -> syn::Result<Args<'_>> {
    let span = input.span();
    match &mut input.data {
        syn::Data::Struct(data_struct) => {
            Ok((data_struct, &input.ident, &mut input.generics, &input.attrs))
        }
        _ => Err(syn::Error::new(span, "must be derived on a data struct")),
    }
}

///
/// Given an [`Args`], returns a [`TokenStream`] corresponding to a valid `yarms_packet::Packet`
/// implementation for that struct.
///
/// # Errors
/// Returns [`Err`] if any required attributes are missing or otherwise invalid.
fn packet_struct_impl(args: Args<'_>) -> syn::Result<TokenStream> {
    let (data_struct, struct_name, struct_generics, struct_attrs) = args;

    let packet_id =
        find_lit_attr!(Int, struct_name, "packet_id", struct_attrs)?.base10_parse::<i32>()?;
    let resource = find_lit_attr!(Str, struct_name, "resource", struct_attrs)?.value();
    let clientbound = find_lit_attr!(Bool, struct_name, "clientbound", struct_attrs)?.value();

    let (impl_generics, type_generics, where_clause) = struct_generics.split_for_impl();

    let mut read_body_impl = quote! {};
    let mut read_return_body = quote! {};
    let mut write_body_impl = quote! {
        let mut __len: usize = 0usize;
    };

    let mut len_body_impl = quote! {
        let mut __len: usize = 0usize;
    };

    for field in &mut data_struct.fields {
        let field_name = field.ident.as_ref().expect("field ident is missing");

        write_body_impl.extend(quote! {
            __len += ::yarms_protocol::ProtocolWrite::write_to(&self.#field_name, __buf);
        });

        len_body_impl.extend(quote! {
            __len += ::yarms_protocol::ProtocolWrite::len(&self.#field_name);
        });

        make_type_generics_static(&mut field.ty);
        let field_type = &field.ty;

        read_return_body.extend(quote! {
            #field_name: <#field_type as ::yarms_protocol::ProtocolRead>::read_from(__buf, __end_remaining)?,
        });
    }

    read_body_impl.extend(quote! {
       ::yarms_protocol::Result::Ok(Self { #read_return_body })
    });

    write_body_impl.extend(quote! {
       __len
    });

    len_body_impl.extend(quote! {
        __len
    });

    Ok(quote! {
        #[automatically_derived]
        impl #impl_generics ::yarms_packet::Packet for #struct_name #type_generics #where_clause {
            fn protocol_id() -> ::yarms_protocol::types::VarInt {
                ::yarms_protocol::types::VarInt::from(#packet_id)
            }

            fn clientbound() -> bool {
                #clientbound
            }

            fn resource() -> &'static str {
                #resource
            }

            fn read_body<B: ::bytes::Buf + ?Sized>(__buf: &mut B, __end_remaining: usize) -> ::yarms_protocol::Result<Self>
                where Self: Sized + 'static
            {
                #read_body_impl
            }

            fn write_body<B: ::bytes::BufMut + ?Sized>(&self, __buf: &mut B) -> usize {
                #write_body_impl
            }

            fn len(&self) -> usize {
                #len_body_impl
            }
        }
    }
    .into())
}

struct StaticTransformer;

impl VisitMut for StaticTransformer {
    fn visit_generic_argument_mut(&mut self, i: &mut syn::GenericArgument) {
        if let syn::GenericArgument::Lifetime(lifetime) = i {
            if lifetime.ident != "static" {
                let span = lifetime.span();
                *lifetime = syn::Lifetime::new("'static", span);
            }
        }

        syn::visit_mut::visit_generic_argument_mut(self, i);
    }
}

fn make_type_generics_static(ty: &mut syn::Type) {
    let mut visitor = StaticTransformer;
    visitor.visit_type_mut(ty);
}

fn make_generics_static(ty: &mut syn::Generics) {
    let mut visitor = StaticTransformer;
    for param in &mut ty.params {
        visitor.visit_generic_param_mut(param);
    }
}

fn protocol_struct_impl(args: Args<'_>) -> syn::Result<TokenStream> {
    let (data_struct, struct_name, struct_generics, _) = args;

    let (impl_generics, type_generics, where_clause) = struct_generics.split_for_impl();

    let mut read_body = quote! {};
    let mut self_body = quote! {};

    let mut write_body = quote! {
        let mut __len: usize = 0;
    };

    let mut len_body = quote! {
        let mut __len: usize = 0;
    };

    for field in &mut data_struct.fields {
        let field_name = field.ident.as_ref().expect("field ident is missing");

        write_body.extend(quote! {
           __len += ::yarms_protocol::ProtocolWrite::write_to(&self.#field_name, __write);
        });

        len_body.extend(quote! {
           __len += ::yarms_protocol::ProtocolWrite::len(&self.#field_name);
        });

        make_type_generics_static(&mut field.ty);
        let field_type = &field.ty;

        self_body.extend(quote! {
            #field_name: <#field_type as ::yarms_protocol::ProtocolRead>::read_from(__read, __end_remaining)?,
        });
    }

    read_body.extend(quote! {
        ::yarms_protocol::Result::Ok(Self::Output { #self_body })
    });

    write_body.extend(quote! {
        return __len;
    });

    len_body.extend(quote! {
        return __len;
    });

    let write_impl = quote! {
        #[automatically_derived]
        impl #impl_generics ::yarms_protocol::ProtocolWrite for #struct_name #type_generics #where_clause {
            fn write_to<B: ::bytes::BufMut + ?Sized>(&self, __write: &mut B) -> usize {
                #write_body
            }

            fn len(&self) -> usize {
                #len_body
            }
        }
    };

    make_generics_static(struct_generics);
    let (impl_generics, type_generics, where_clause) = struct_generics.split_for_impl();

    let read_impl = quote! {
        #[automatically_derived]
        impl #impl_generics ::yarms_protocol::ProtocolRead for #struct_name #type_generics #where_clause {
            type Output = #struct_name #type_generics;

            fn read_from<B: ::bytes::Buf + ?Sized>(__read: &mut B, __end_remaining: usize) -> ::yarms_protocol::Result<Self::Output> {
                #read_body
            }
        }
    };

    Ok(quote! {
       #read_impl

       #write_impl
    }
    .into())
}
