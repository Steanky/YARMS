use serde_derive::{Deserialize, Serialize};
use std::collections::{BTreeMap, HashSet};
use yarms_identifier::Identifier;

#[cfg(feature = "packet")]
///
/// Packet specifications.
pub mod packet;

///
/// A "protocol specification", used by code generation facilities to create the structures needed
/// for a given protocol version automatically. Also includes documentation.
#[derive(Deserialize, Serialize)]
pub struct ProtocolSpec {
    ///
    /// The protocol version.
    pub id: i32,

    #[cfg(feature = "packet")]
    ///
    /// Types used by packets.
    ///
    /// Each key is a type as referenced in a [`packet::PacketFieldSpec`]. Each value is a valid
    /// Rust _global path_ that should point to something that has a `ProtocolRead` and
    /// `ProtocolWrite` implementation.
    ///
    /// Since `yarms-protocol` is necessary for virtually any non-trivial packet definitions, many
    /// paths will point at something in `::yarms_protocol::types`. Less version-agnostic types,
    /// such as those generated by `yarms-datagen` to go along with the packets that need them, will
    /// exist somewhere in `::yarms_datagen`.
    pub packet_type_spec: BTreeMap<String, String>,

    #[cfg(feature = "packet")]
    ///
    /// Packet specifications for this version.
    pub packet: Vec<packet::PacketSpec>,

    #[cfg(feature = "packet")]
    ///
    /// Specifies auxiliary data structures used by packets.
    pub packet_data: Vec<packet::PacketDataSpec>,
}

///
/// Options to pass to the packet specification validation function [`validate_spec`].
///
/// Which options are available generally depends on the enabled features. For example, to turn on
/// packet-related settings, the `packet` feature must be enabled.
pub struct ValidateOpts {
    #[cfg(feature = "packet")]
    allow_missing_packet_typedefs: bool,
}

impl ValidateOpts {
    ///
    /// Creates a new instance of the validation options builder. All settings are initially false.
    pub fn new() -> Self {
        Self {
            #[cfg(feature = "packet")]
            allow_missing_packet_typedefs: false,
        }
    }

    #[cfg(feature = "packet")]
    ///
    /// If enabled, packet validation will not check for missing type definitions (i.e. types that
    /// are used in packet fields, but do not have a corresponding definition in
    /// `packet_type_spec`).
    pub fn allow_missing_packet_typedefs(mut self) -> Self {
        self.allow_missing_packet_typedefs = true;
        self
    }
}

///
/// Attempt to detect invalid protocol specifications, and return a descriptive error if there's a
/// problem.
///
/// This function only makes a best-effort attempt at finding invalid specifications; it is
/// possible that invalid data (that may even cause compilation failures in the generated code)
/// will be undetected.
pub fn validate_protocol_spec(
    protocol_spec: &ProtocolSpec,
    opts: ValidateOpts,
) -> Result<(), Vec<String>> {
    let mut err_msgs = Vec::new();

    #[cfg(feature = "packet")]
    {
        let mut names = HashSet::new();
        let mut types = HashSet::new();
        let mut specs = HashSet::new();

        for packet_spec in protocol_spec.packet.iter() {
            if !Identifier::is_valid_identifier(&packet_spec.resource) {
                err_msgs.push(format!(
                    "Found invalid resource identifier `{}` (name {}, state {}, clientbound {}, protocol identifier {})",
                    packet_spec.resource, packet_spec.name, packet_spec.state, packet_spec.clientbound, packet_spec.packet_id
                ));
            }

            if !specs.insert(&*packet_spec) {
                err_msgs.push(format!(
                    "Found duplicate packet definition for `{}` (state {}, clientbound {}, protocol identifier {})",
                    packet_spec.name, packet_spec.state, packet_spec.clientbound, packet_spec.packet_id
                ));
            }

            if !names.insert((&packet_spec.name, packet_spec.clientbound)) {
                err_msgs.push(format!(
                    "Found duplicate packet name `{}` (state {}, clientbound {}, protocol identifier {})",
                    packet_spec.name, packet_spec.state, packet_spec.clientbound, packet_spec.packet_id
                ));
            }

            for field in &packet_spec.fields {
                if !opts.allow_missing_packet_typedefs
                    && !protocol_spec
                        .packet_type_spec
                        .contains_key(&field.protocol_type)
                {
                    if types.insert(&field.protocol_type) {
                        err_msgs.push(format!(
                            "Found type `{}` that is missing a corresponding definition (name {}, state {}, protocol identifier {})",
                            &field.protocol_type, &packet_spec.name, &packet_spec.state, &packet_spec.packet_id
                        ));
                    }
                }
            }
        }
    }

    if !err_msgs.is_empty() {
        return Err(err_msgs);
    }

    Ok(())
}
